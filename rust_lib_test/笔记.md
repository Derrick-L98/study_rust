# 备忘录

```c++
https://github.com/rust-random/rand
网页打开vscode 并运行项目
https://gitpod.io/#/github.com/rust-random/rand

在github 代码详情页  按句号键 网页打开vscode 查看代码

开发服务器：172.16.1.220   dev/12341234

查看是否安装成功：protoc --version

开发服务器：172.16.1.220   dev/12341234

mysql地址
ip: 139.217.229.20 
端口：13301
用户名：dbtest
密码：AXJFEc55gpGbt51Z

//gitlab
http://gitlab.metestsvr.com/
账号：luohuajin
密码：luohuajin@123

sourcetree//代码管理工具

http://172.16.1.202/



http://172.16.1.201:8023/

http://gitlab.metestsvr.com/  => http://172.16.1.201:8023/


编译服务器账号
luohuajin 密码：wxVZ6q*k
服务器地址：172.16.1.211


禅道 http://lanlian.chandao/
用户名：luohuajin
密码：Lanlian!123

测试环境日志路径 /home/develop/stock-oms/oms/log

公司wife账号密码：lanlian_dev 密码：lanlian190

172.16.1.211
devuser
123123

//暂停 重启 服务命令
sudo systemctl stop/start/restart servername.service

//动态查看日志
tail -f logname.log

//邮箱创建好了！
登录名：名字全拼@xlanlian.com
密码：Lanlian@123
登陆地址：https://exmail.qq.com/


日志文件服務器：
地址：http://log.lionky.com:81/finder
賬號、密碼：fhj、l586482546|1234
    
redis集群接口信息，查看：http://172.16.1.201:8181/blog-1.html


vs code Rust代码自动推导类型显示
rust-analyzer

//测试服务器
uat-stock.chinaeast2.cloudapp.chinacloudapi.cn
//集群服务器: 
地址:uat-stock-ha.chinaeast2.cloudapp.chinacloudapi.cn
端口:22
usr:develop
pass:BiY4ljuJoWLuaiHg
    
./SVRCTL -r//批量重启
    
    
运营中心 http://uat-stock-ha.chinaeast2.cloudapp.chinacloudapi.cn:89/   
账号密码:  admin/ad542369
 
    
启动 sudo systemctl start 服务名.service
关闭 sudo systemctl stop 服务名.service
重启 sudo systemctl restart 服务名.service
    
    
QFII和RQFII是什么意思？有什么区别
 https://www.gprmjczs.com/article/507.html   

c++: https://github.com/sewenew/redis-plus-plus
go: https://github.com/wuxibin89/redis-go-cluster
```

# Rust

### 项目常用框架

```rust
//数据库
    mysql_async = "0.29.0"
    
//redis
    redis = { version = "0.21", features = ["tokio-comp", "cluster", "r2d2"] }
    redis_cluster_async = "0.7"
    mobc-redis = "0.7.0"
    mobc = "0.7.3"
//Cassandra
    cdrs-tokio = "6.2.0"
    cdrs = { version = "2" }
    cassandra_macro = "0.1.2"
    cassandra_macro_derive = "0.1.2"
    env_logger = "0.9.0"
    maplit = "1.0.0"
    regex = "1.5.4"
    cdrs_helpers_derive = "0.4.0"

    scylla = "0.4.4"
//异步框架
    tokio = { version = "1.0", features = [ "rt-multi-thread", "time", "fs", "macros", "net", "full"] }
    tokio-stream = { version = "0.1", features = ["net"] }
//gRPC
    tonic-build = { version = "0.7.0", features = ["prost", "compression"] }
    protobuf = { version = "2.27.1", features = ["with-bytes"] }
    tonic = { version = "0.7.1", features = ["tls", "compression"] }
    prost = "0.10.1"
    # Required for wellknown types
    prost-types = "0.10.1"
//时间
//mq
    lapin = { version = "2", default-features = false, features = ["rustls"] }
//序列化
    serde = { version = "1.0", features = ["derive"] }
    serde_json = "1.0"

//数据结构
ringbuf = "0.2.8"
triple_buffer = "6.0.0"
Crossbeam

tracing = "0.1"
//tracing是一个用于检测 Rust 程序以收集结构化的、基于事件的诊断信息的框架。
//在像 Tokio 这样的异步系统中，解释传统的日志消息通常非常具有挑战性。由于单个任务在同一线程上多路复用，因此关联的事件和日志行是混合的，因此很难跟踪逻辑流。 通过允许库和应用程序使用有关时间性和因果关系的其他信息来扩展日志记录样式的诊断 — 与日志消息不同，跨度具有开始和结束时间，可以通过执行流进入和退出，并且可能存在于具有类似跨度的嵌套树中。此外，跨度是结构化的，能够记录类型化的数据以及文本消息。tracingtracingtracing



//缓存
vsdb = "0.34.1"//有状态数据库,主要用于区块链场景。

//channel
ring-channel = "0.11.0"
//此板条箱提供了一种消息传递风格，有利于吞吐量而不是无损通信。在引擎盖下，ring_channel只是多生产者多消费者无锁环形缓冲区之上的一个薄抽象层。发送消息永远不会阻塞，但是如果内部缓冲区溢出，消息可能会丢失，因为传入的消息会逐渐覆盖较旧的挂起消息。此行为非常适合于使用线程只关心最新消息且不希望对生产者线程施加背压的用例。
```



```rust
async 异步函数时惰性的,只有遇到.await 才会执行


pub fn unbounded_channel<T>() -> (UnboundedSender<T>, UnboundedReceiver<T>)
创建无界 mpsc 通道，用于在没有背压的情况下在异步任务之间进行通信。
只要接收半数尚未关闭，此通道上的 A 将始终成功。如果接收方落后，消息将被任意缓冲。send
请注意，可用系统内存量是与通道的隐式绑定。使用通道会导致进程内存不足。在这种情况下，该过程将中止。unbounded

use std::sync::mpsc::channel;
pub fn channel<T>() -> (Sender<T>, Receiver<T>)
创建新的异步通道，返回发送方/接收方的一半。发送器上发送的所有数据都将以与发送时相同的顺序在接收方上可用，并且没有发送将阻塞调用线程（此通道具有“无限缓冲区”，这与sync_channel不同，后者将在达到其缓冲区限制后阻塞）。recv 将阻止，直到邮件可用，而至少有一个发件人处于活动状态（包括克隆）。
可以克隆发送方以多次发送到同一通道，但仅支持一个接收方。

如果在尝试使用发送方发送时接收方断开连接，则 send 方法将返回 SendError。同样，如果在尝试 recv 时发送程序断开连接，则 recv 方法将返回 RecvError。
```



所有权同一时间只能一人持有，可变引用也只能同时被一个实例持有，不可变引用则可以被多个实例持有。同时所有权能被转移，在Rust中被称为 `move` 。

## 资源网站

```rust
https://www.wenjiangs.com/doc //教程.

https://crates.io/
```



```rust
cargo build
cargo build --release # 这个属于优化编译
./target/debug/hellorust.exe
./target/release/hellorust.exe # 如果前面是优化编译，则这样运行
cargo run # 编译和运行合在一起
cargo run —release # 同上，区别是是优化编译的
```



## 数据类型注意点

```rust
数值类型可以使用_分隔符来增加可读性。
Rust还支持单字节字符b'H'以及单字节字符串b"Hello"，仅限制于ASCII字符。
此外，还可以使用r#"..."#标记来表示原始字符串，不需要对特殊字符进行转义。
使用&符号将String类型转换成&str类型很廉价，
但是使用to_string()方法将&str转换到String类型涉及到分配内存，
除非很有必要否则不要这么做。
数组的长度是不可变的，动态的数组称为Vec (vector)，可以使用宏vec!创建。
元组可以使用==和!=运算符来判断是否相同。
不多于32个元素的数组和不多于12个元素的元组在值传递时是自动复制的。
Rust不提供原生类型之间的隐式转换，只能使用as关键字显式转换。
可以使用type关键字定义某个类型的别名，并且应该采用驼峰命名法。
```

## 定义项目依赖

-   基于rust官方仓库crates.io，通过版本说明来描述：
-   基于项目源代码的git仓库地址，通过URL来描述：
-   基于本地项目的绝对路径或者相对路径，通过类Unix模式的路径来描述：
    这三种形式具体写法如下：

```rust
[dependencies]
typemap = "0.3"
plugin = "0.2*"
hammer = { version = "0.5.0"}
color = { git = "https://github.com/bjz/color-rs" }
geometry = { path = "crates/geometry" }


定义集成测试用例
[[test]]
name = "testinit"
path = "tests/testinit.rs"
[[test]]
name = "testtime"
path = "tests/testtime.rs"
```



## struct String库

```rust
String::contains
//查找字符串子串
pub fn contains<'a, P>(&'a self, pat: P) -> bool
where
    P: Pattern<'a>, 

// Returns true if the given pattern matches a sub-slice of this string slice.
// Returns false if it does not.
// The pattern can be a &str, char, a slice of chars, or a function or closure that determines if a character matches.

//Examples
//Basic usage:

let bananas = "bananas";
assert!(bananas.contains("nana"));
assert!(!bananas.contains("apples"));


pub fn starts_with<'a, P>(&'a self, pat: P) -> bool
where
    P: Pattern<'a>, 
// Returns true if the given pattern matches a prefix of this string slice.
// Returns false if it does not.
// The pattern can be a &str, char, a slice of chars, or a function or closure that determines if a character matches.

// Examples
// Basic usage:

let bananas = "bananas";

assert!(bananas.starts_with("bana"));
assert!(!bananas.starts_with("nana"));


pub fn ends_with<'a, P>(&'a self, pat: P) -> bool
where
    P: Pattern<'a>,
    <P as Pattern<'a>>::Searcher: ReverseSearcher<'a>, 

// Returns true if the given pattern matches a suffix of this string slice.
// Returns false if it does not.
// The pattern can be a &str, char, a slice of chars, or a function or closure that determines if a character matches.

// Examples
// Basic usage:

let bananas = "bananas";

assert!(bananas.ends_with("anas"));
assert!(!bananas.ends_with("nana"));



//判断字符串是否为空
is_empty()
let s2 = "";
println!("{}",s2.is_empty());
如果此字符串的长度为零，则返回true，否则返回false
```

## 字符串

### 索引访问

有人会把Rust中的字符串和其惯用的字符串等同起来，于是就出现了如下代码

```rust
let x = "hello".to_string();
x[1]; //编译错误！
```

Rust的字符串实际上是不支持通过下标访问的，但是呢，我们可以通过将其转变成数组的方式访问

```rust
let x = "哎哟我去".to_string();
for i in x.as_bytes() {
	print!("{} ", i);
}
println!("");
for i in x.chars() {
	print!("{}", i);
}
x.chars().nth(2);
```





有了数组和向量的基础，我们再来看它的一个特例：字符串。

字符串有两种表现形式，一种是基本类型，表示字符串的切片，以&str表示；另一种是可变的string类型。

针对字面值的字符串，有一种静态的类型表示方法，写作&'static str。

字符串切片具有普通切片的基本功能。

### 字符串切片长度

与普通切片一样，可以用len方法来求字符串切片的长度。

例：

```rust
    let s1 = "Hello,String";
    println!("{:?}",s1.len());
```

输出结果为12.

### 判断字符串切片是否为空

可以通过is_empty方法判断一个字符串切片是否为空。

```rust
    let s2 = "";
    println!("{}",s2.is_empty());
```

### 将字符串按行拆分

可以通过lines方法将字符串切片拆分成行的迭代，这样就可以用for循环去处理每一行。

我们看个小例子：

```rust
    let str3 = "Hello\nWorld";
    for str_1 in str3.lines(){
        println!("str_1={}",str_1);
    }
```

### 判断当前字符串是否包含某子串

contains函数用于判断某一个子串是否是当前字符串切片的子串。

我们来看个例子，看看""Hello,String"中是否有"ello"：

```rust
    let s1 = "Hello,String";
    println!("{}",s1.contains("ello"));
```

输出结果当然为true.

特别的，如果判断是否是以某串起始，可以使用starts_with函数；同样，判断是否以某串结尾，可以使用ends_with函数。

例：

```rust
    println!("{}",s1.starts_with("/"));
    println!("{}",s1.ends_with(";"));
```

如果我们希望查找到第一次出现的位置，我们可以使用find方法。

我们看个例子：

```rust
    let s1 = "Hello,String";
    println!("{:?}",s1.find("l"));
```

只能给静态字符串还是太弱，针对复杂条件，我们还可以给一个函数进去，比如char包中给我们提供的判断字符串类型的方法都可以用上。比如查找第一个字符，我们不写正则表达式了，直接上char::is_whitespace函数：

```rust
println!("{:?}",s1.find(char::is_whitespace));
```

或者条件比较复杂，我们自己写个函数：

```rust
    fn is_great_o (x: char) -> bool {
        (x > 'O' && x <= 'Z') || (x > 'o' && x <= 'z')
    }
    println!("{:?}",s1.find(is_great_o));
```

懒得写函数了，直接在find里面写也没问题：

```rust
s1.find(|x| (x > 'O' && x <= 'Z') || (x > 'o' && x <= 'z'));
```

代码里的`|x| (x > 'O' && x <= 'Z') || (x > 'o' && x <= 'z')`叫做闭包，也就是匿名函数。“｜变量名｜”用以捕获外界的变量，后面是返回值。可能通过"->"指定类型，也可以让系统自己推断。

加上类型之后的写法是下面这样：

```rust
s1.find(|x :char | -> bool  {(x > 'O' && x <= 'Z') || (x > 'o' && x <= 'z')});
```

加上类型之后，为了区分函数体，我们需要给函数体加上花括号。

更进一步，我们不光想知道第一次出现的位置，需要所有的匹配的位置，可以使用matches方法。
 我们来看例子，假如我们想得到所有的小写字母：

```rust
    for str in s1.matches(char::is_lowercase){
        println!("str={:?}",str);
    }
```

输出结果为

```rust
str="e"
str="l"
str="l"
str="o"
str="t"
str="r"
str="i"
str="n"
str="g"
```

更进一步，如果我们不光想遍历符合条件的字符串，还想同时知道符合条件的子串的位置，我们可以使用match_indices方法：

```rust
    for str in s1.match_indices(char::is_lowercase){
        println!("match={:?}",str);
    }
```

输出结果为:

```rust
match=(1, "e")
match=(2, "l")
match=(3, "l")
match=(4, "o")
match=(7, "t")
match=(8, "r")
match=(9, "i")
match=(10, "n")
match=(11, "g")
```

### 拆分成子字符串

这也是字符串中最常用的基本操作之一，根据某分隔符将子符串拆分成一些子串，可以使用split方法来实现。
 我们看个例子：

```rust
    let str4 = "/workspace/xulun/alios";
    for str_2 in str4.split("/"){
        println!("str4={}",str_2);
    }
```

输出结果为：

```undefined
str4=
str4=workspace
str4=xulun
str4=alios
```

### 截掉无用字符

我们从文件中或者是网络上获得的字符串，经常是前后带有空白符的。此时我们可以调用trim方法将前后的空白去掉。

```rust
    let str5 = "\t\t\tHello\n\r";
    println!("{:}",str5.trim());
```

如果只想trim前缀的空白，可以使用trim_start方法；同理，后缀的可以使用trim_end。

```rust
    let str5 = "\t\t\tHello\n\r";
    println!("{:}",str5.trim());
    println!("{:}",str5.trim_start());
    println!("{:}",str5.trim_end());
```

如果想要去除的不是空白符，而是想自定义的其他字符，Rust提供了trim_matches，跟matches一样，可以给字符，字符串切片，函数或者闭包。
 同样，如果只针对前缀，可以使用trim_start_matches；后缀使用trim_end_matches.

例如，我们想把前缀的路径符号去掉：

```rust
    let str4 = "/workspace/xulun/alios";
    for str_2 in str4.split("/"){
        println!("str4={}",str_2.trim_start_matches('/'));
    }
```

### 字符串替换

刚才的trim系只能处理前缀和后缀，如果要处理整个字符串，那就是字符串替换该做的事情了。

我们来个例子，把字符串里的“l”全部替换成空：

```rust
println!("{:}",str5.replace("l",""));
```

### 生成重复的字符串

这个没啥技术含量了。直接上例子：

```rust
println!("{}","a".repeat(10));
```

输出：

```undefined
aaaaaaaaaa
```

### 将字符串解析成其它类型

字符串的常用操作研究差不多了，我们研究下将字符串转成其它类型，最常用的是转换成数字。这要用到字符串切换的parse方法。

parse可能成功，也可能失败，所以返回的结果不是一个数，而是一个Result类型的结构。如果成功的话，返回Ok(数字)；如果失败的话，返回Err(错误类型).

我们来看几个例子，比如我们想把字符串"4"解析成i32整数：

```rust
println!("{:?}","4".parse::<i32>());
```

输出结果为：

```rust
Ok(4)
```

如果我们想获取4这个值，可以调用unwrap方法：

```rust
println!("{:?}","4".parse::<i32>().unwrap());
```

下面我们再看如何处理错误的情况，比如我们拿到的字符串不是"4"而是"4.0"，解析出发的结果如下：

```rust
println!("{:?}","4.1".parse::<i32>());
```

输出如下：

```css
Err(ParseIntError { kind: InvalidDigit })
```

可以看到，错误是InvalidDigit类的ParseIntError。关于Rust的错误处理，我们将在后面介绍。

### 可变的字符串String

这一节的最后，我们再简单介绍下可变的字符串。前面的字符串切片有点像Java中的String，而可变字符串就像是StringBuffer或者StringBuilder。
 在Rust中，String类型其实就是对Vec<u8>的封装，本质上就是一个向量。

因为就是向量，所以我们可以用向量的with_capacity来创建一个字符串：

```rust
let mut str5 = String::with_capacity(10);
```

如果在String末尾增加一个字符，则就像向量添加元素一样使用push。如果要增加一个字符串切片的话，可以使用push_str方法：

```rust
    let mut str5 = String::with_capacity(10);
    str5.push_str("Hello");
    println!("{:?} {}",str5,str5.capacity());
```

比起从头构建String，从一个字符串切片生成字符串是更常见的做法，这就是常用的to_string方法:

```rust
let mut str6 = "Hello".to_string();
```

如果不是在末尾push_str，而是需要在中间插入字符串的话，可以使用insert_str方法：

```rust
    let mut str6 = "Hello".to_string();
    str6.insert_str(5,"World!");
    println!("{:?} {}",str6,str6.capacity());
```

### 小结

这一节我们集中介绍了Rust中的字符串切片&str和可变字符串String的用法。除了要修改的赋值要加mut之外，跟其它语言其实还是蛮相似的吧，隐隐约约还有点函数式编程的味道。

### 分割字符串

```rust
//根据指定模式分割字符串 split()
如果要将字符串根据某些指定的 字符串子串 分割，则可以使用 split() 方法。

split() 会根据传递的指定 模式 （字符串分割符） 来分割字符串，并返回分割后的字符串子串组成的切片上的迭代器。我们可以通过这个迭代器来迭代分割的字符串子串。

split() 方法最大的缺点是不可重入迭代，也就是迭代器一旦使用，则需要重新调用才可以再用。

但我们可以先在迭代器上调用 collect() 方法将迭代器转换为 向量 Vector ，这样就可以重复使用了。

fn main() {
   let fullname = "李白，诗仙，唐朝";

   for token in fullname.split("，"){
      println!("token is {}",token);
   }

   // 存储在一个向量中
   println!("\n");
   let tokens:Vec<&str>= fullname.split("，").collect();//分割字符串
   println!("姓名 is {}",tokens[0]);
   println!("称号 {}",tokens[1]);
   println!("朝代 {}",tokens[2]);
}
```



## rust时间使用：

```rust
pub struct NaiveDateTime {
    date: NaiveDate,
    time: NaiveTime,
}
Date 只有年月日, 例如 2021-1-4.
即： 2021-1-4 => Date = NaiveDate

Time 只有 时间，例如: 19:28:33.
即: 19:28:33 => Date = NaiveTime

DateTime 包含日期和时间.
即：2021-1-4 19:28:33 => Date + Time = NaiveDateTime
//构造
let dt =NaiveDateTime::parse_from_str("2022-05-05 14:21:48.000", "%Y-%m-%d %H:%M:%S%.3f").unwrap();
println!("{}", dt);//2022-05-05 22:21:48
println!("{:?}", dt);//2022-05-05T22:21:48


//前置准备

//Cargo.toml
# time
chrono = { version = "0.4", features = ["serde"] }

# 引入
use chrono::{DateTime, Local, NaiveDateTime, Duration};

//当前系统时间
let now:NaiveDateTime = Local::now().naive_local();

//从String转换
let end_time = NaiveDateTime::parse_from_str("2020-03-06 18:36:27", "%Y-%m-%d %H:%M:%S").unwrap_or(now);

//时间增减操作
// 减 9 分钟 
let start_time = end_time.sub(Duration::minutes(9));

//时间按格式输出String
let start_day = start_time.format("%Y%m%d").to_string();


//////////////////////////////////////////////////////////////////////////////////////////////
//一种是采用系统库timestamp1，一种是采用第三方库timestamp2，但是由于time库已经不在维护，所以推荐使用官方库。
//目前rust的时间库为chrone
use std::time::{SystemTime, UNIX_EPOCH};
 
extern crate time;
 
fn timestamp2() -> i64 {
    let timespec = time::get_time();
    timespec.sec * 1000 + (timespec.nsec as f64 / 1000.0 / 1000.0) as i64
}
 
fn timestamp1() -> i64 {
    let start = SystemTime::now();
    let since_the_epoch = start
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards");
    let ms = since_the_epoch.as_secs() as i64 * 1000i64 + (since_the_epoch.subsec_nanos() as f64 / 1_000_000.0) as i64;
    ms
}
 
fn main() {
    let ts1 = timestamp1();
    println!("TimeStamp1: {}", ts1);
    let ts2 = timestamp2();
    println!("TimeStamp2: {}", ts2);


    
//不过虽然time库不在维护，又出现一个新的时间库chrone
//而且用法更简单，推荐如下这种方式    
    
use chrono::prelude::*;
 
extern crate chrono;
 
fn main() {
    let dt = Local::now();
    println!("dt: {}", dt);
    println!("dt: {}", dt.timestamp_millis());

    
    
 let dt = Local::now();
    println!("dt: {}", dt);								//////1
    println!("dt: {}", dt.timestamp_millis());				//////2
    let now:NaiveDateTime = Local::now().naive_local();
    println!("now: {}", now);							///////3
    let mut tsecond: i64 = 0;
    let now = now.timestamp_millis();
    //let now = Local::now().naive_local().timestamp_millis();//获取系统时间转换成秒
                    tsecond = now - 15*60;
    println!("now: {}", now);							/////4
    println!("tsecond: {}", tsecond);					//////5
    let dt/*: DateTime<Local>*/ = Local.timestamp_millis(tsecond);
    println!("{}",dt);									/////6
    
dt: 2021-11-08 19:51:17.138889900 +08:00				//1
dt: 1636372277138										//2
now: 2021-11-08 19:51:17.149579600						///3
now: 1636401077149									//4
tsecond: 1636401076249									//5
2021-11-09 03:51:16.249 +08:00							//6
    
    
    
extern crate chrono; // 时间库
extern crate time; // 时间戳，差值
use chrono::prelude::*;
// =========== 时间 格式化和计算
// 这个 time::Duration 和 use std::time::Duration; 是不一样的。chrono 是用的这个 time::Duration，这里as了一下是为和 标准库 区分
//use time::Duration as Durationx; 
// time::Duration 已经升级为 chrono::Duration，所以改为
use chrono::Duration as Durationx; //这样就可以编译通过了
// std::time::Duration; 这个是用在线程休眠上 比如 thread::sleep(Duration::from_secs(1));
fn time_x() {
    let sys_time = SystemTime::now();
    println!("now time 显示的是一个长整数 {:?}", sys_time);
    let local: DateTime<Local> = Local::now(); // 本地时间
    println!(
        " date 精确到秒 ({:?})",
        local.format("%Y-%m-%d %H:%M:%S").to_string()
    );
    println!(
        " date 精确到毫秒 ({:?})",
        local.format("%Y-%m-%d %H:%M:%S%.3f").to_string()
    );
    println!(
        " date 精确到微秒 ({:?})",
        local.format("%Y-%m-%d %H:%M:%S%.6f").to_string()
    );
    println!(
        " date 精确到纳秒 ({:?})",
        local.format("%Y-%m-%d %H:%M:%S%.9f").to_string()
    );
    let _t0u0 = Utc.ymd(2014, 7, 8).and_hms_micro(9, 10, 11, 12_000); // Utc带时区 全球时间
    let _t0u1 = Utc.ymd(2014, 7, 8).and_hms_nano(9, 10, 11, 12_000_000);
    let _t0l0 = Local.ymd(2014, 7, 8).and_hms_micro(9, 10, 11, 12_000); // 本地时间
    let _t0l1 = Local.ymd(2014, 7, 8).and_hms_nano(9, 10, 11, 12_000_000);
    // 时间加减
    let _t0_as_0 = Utc.ymd(1970, 1, 1).and_hms(0, 0, 0) + Durationx::seconds(1_000_000_000);
    let _t0_as_1 = Utc.ymd(2020, 2, 1).and_hms(0, 0, 0)
        - Durationx::from_std(Duration::from_secs(1_000_000_258)).unwrap();
    println!(
        " 本地时间 20200201 + 1_000_000_000 10亿秒 把标准库10亿秒转换成time10亿秒 再加时间计算 {:?}",
        _t0_as_1.format("%y-%m-%d %H:%M:%S.%3f").to_string()
    );

    let _t0_as_2 = Local.ymd(2020, 1, 1).and_hms(0, 0, 0)
        + Durationx::from_std(Duration::from_millis(1_258_101_957)).unwrap(); // Durationx::from_std 方法从标准库的时间戳转换

    println!(
        " 本地时间 20200101 + 2_000_000_000 20亿秒 转换标准库 12亿 毫秒 {:?}",
        _t0_as_2.format("%y-%m-%d %H:%M:%S.%3f").to_string()
    );

    println!(
        " 本地时间 20200101 + 2_000_000_000 20亿秒 {:?}",
        _t0_as_2.format("%Y-%m-%d %H:%M:%S.%6f").to_string()
    );
    println!(
        " 本地时间 20200101 + 2_000_000_000 20亿秒 {:?}",
        _t0_as_2.format("%Y-%m-%d %H:%M:%S.%9f").to_string()
    );
    let t0_fmt_01 =
        DateTime::parse_from_str("1983 Apr 13 12:09:14.274 +0000", "%Y %b %d %H:%M:%S%.3f %z"); // 注意 %.3f 这个写法
    println!(
        r#" 从字符串 "1983 Apr 13 12:09:14.274 +0000", 格式字符： "%Y %b %d %H:%M:%S%.3f %z" 格式化而来的时间 显示 {:?}"#,
        t0_fmt_01.unwrap()
    );
    // 字符串转换时间类型
    let t1: ParseResult<DateTime<FixedOffset>> =
        DateTime::parse_from_str("2020-03-28 21:00:09 +09:00", "%Y-%m-%d %H:%M:%S %z");
    println!("t1: ParseResult<DateTime<FixedOffset>>({:?})", t1);
    // 常见转换输入 写法 .ok().unwrap() 很重要
    let t2: ParseResult<DateTime<Utc>> =
        Utc.datetime_from_str("2020-03-06 12:00:09", "%Y-%m-%d %H:%M:%S");
    println!(
        "t2: ParseResult<DateTime<Utc>>({:?})",
        t2.ok().unwrap().format("%y-%m-%d %H:%M:%S").to_string()
    );
    //
    let t3: DateTime<Local> = Local
        .datetime_from_str("2020-03-28 12:00:09", "%Y-%m-%d %H:%M:%S")
        .ok()
        .unwrap();
    println!("t3: DateTime<Local>({:?})", t3);
}
    
    
/////////////////////////////////////////////////////////////////////////   
time = "0.3.4"
chrono = "0.4.19"    
    
extern crate chrono;
extern crate wasm_bindgen_test;

use self::chrono::prelude::*;
use self::wasm_bindgen_test::*;
use self::chrono::offset::Local;

fn main() {
    // let utc: DateTime<Utc> = Utc::now();
    // let local: DateTime<Local> = Local::now();

    // let now = Local::now();//str
    // let ndt = now.naive_local();//chrono::NaiveDateTime
    // let res = match Local.from_local_datetime(&ndt).single() {
    //     Some(v) => v,
    //     None => panic! {"Required for test!"},
    // };//chrono::DateTime<chrono::Local>
    // println!("now:{}\nndt:{}\nres:{}",now, ndt,res);

    // println!("utc = {}\nlocal = {}",utc, local);
    // println!("Hello, world!");
    // let dt = Local.ymd(2014, 7, 24).and_hms(12, 34, 6);
    // println!("{}",dt);
    // let dt = FixedOffset::east(9*3600).ymd(2014, 11, 28).and_hms_nano(21, 45, 59, 324310806);
    // let year = dt.year();
    // let month = dt.month()+1; 
    // let day = dt.day();
    // let hour = dt.hour();
    // let minute = dt.minute();
    // let second = dt.second();
    // println!("{}\n{}-{}-{} {}:{}:{}",dt,year,month,day,hour,minute,second);
    // assert_eq!(dt.weekday(), Weekday::Fri);
    // assert_eq!(dt.weekday().number_from_monday(), 5); // Mon=1, ..., Sun=7
    
    let tt = Local::now();
    let t = tt.hour();
    tt.year();
    tt.month();
    tt.day();
    tt.hour();
    tt.minute();
    tt.second();
    tt.timestamp_millis();
    tt.weekday();
    println!("{}\n{}\n{}\n{}\n{}\n{}\n{}\n{}\n{}\n{}\n",tt, 
    tt.year(),              //年
    tt.month(),             //月
    tt.day(),               //天
    tt.hour(),              //小时
    tt.minute(),            //分
    tt.second(),            //秒
    tt.timestamp_millis(),  //时间戳（单位：微秒）
    tt.date(),              //日期
    tt.weekday(),           //周
    );
    let s = Local.timestamp_millis(tt.timestamp_millis());//时间戳转换成时间
    println!("时间戳转换成时间；{}\n",s);
    // let tt = Local::now().naive_local();
    println!("处理过的时间：{}\n",(tt.year() as u64)* 10000000000 + 
                    (tt.month() as u64)* 100000000  + 
                    (tt.day() as u64 )* 1000000 + 
                    (tt.hour() as u64)* 10000 + 
                    (tt.minute() as u64)* 100);//20211111165400

    let tt = Local::now().naive_local();//2021-11-11 16:54:20.415889600
    println!("日期时间（无时区）{}\n",tt);
    println!("时间戳：{}\n",tt.timestamp_millis());//1636649660415
    
}
}

    {
        let tt = Local::now();
        println!("tt：{}",tt);//2021-11-11 16:54:20.415889600 +08：00
        
        let data = tt.timestamp_millis()/1000; //时间戳
        println!("时间戳；{}\n",data);//------------------------------------------------------------------1

        let s = Local.timestamp_millis(data*1000).naive_local();//时间戳转换成时间
        println!("时间戳转换成时间；{}\n",s);//----------------------------------------------------------------2
    }
    println!("--------");
	{
        let tt = Local::now().naive_local();//2021-11-11 16:54:20.415889600
        println!("日期时间（无时区）{}\n",tt);
        
        let s = tt.timestamp_millis()/1000;
        println!("时间戳：{}\n",s);//1636649660415//-------------------------------------------------------1
        
        let s = Local.timestamp_millis(s*1000).naive_local();//时间戳转换成时间
        println!("时间戳转换成时间；{}\n",s);//-----------------------------------------------------------------3
    }
    println!("--------");
    
    
    注意：
    Local::now() 和 Local::now().naive_local();获取时间的区别在于 
    1、前者获取到的时间带有时区（+08:00），后者不带。时间时间相同
    2、由前者获得的时间戳，比后者获得的时间戳少8小时，因此时间戳转换的时间差8小时
```



```rust
extern crate time;

use std::thread;
use time::*;

fn main(){

    
    let start = time::now();//获取开始时间

/*    let handles :Vec<_> =(0..10).map(|_|{
        thread::spawn(||{
            let mut x= 0;
            for _ in (0..5_000_000){
                x+=1
            }
            x
        })
    }).collect();
    for h in handles{
        println!("Thread finished with count={}",h.join().map_err(|_| "Could not join a thread!").unwrap());
    }
*/
    let end = time::now();//获取结束时间
    println!("done!start : {:?},end :{:?},duration:{:?}",start,end,end-start);
}
```



## 类型转换

```rust
//Rust 提供了多种类型转换的方式。

as T

用于数类型之间的转换。ixx, uxx, fxx 都可以。
注意：当溢出的时候，转换不会 panic，而是循环映射值。

fn as_type() {
    // i32 -> i8
    println!("{}", 127i32 as i8);
    // output: 127
    println!("{}", 128i32 as i8);
    // output: -128

    // f64 -> i32 (floor)
    println!("{}", -10000.678f64 as i32);
    // output: -10000

    // integer divide
    for i in 1..10 {
        print!("{} ", i / 2);
    }
    // output: 0 1 1 2 2 3 3 4 4
    println!();

    // float divide
    for i in 1..10 {
        print!("{} ", i as f64 / 2.0);
    }
    // output: 0.5 1 1.5 2 2.5 3 3.5 4 4.5
    println!();
}


TryFrom/TryInto
可以在不同的数类型之间转换，越界时，会返回错误。
TryFrom/TryInto 的结果是 Result<T, Error>
use std::convert::TryFrom;
use std::convert::TryInto;

fn try_from_try_into() {
    println!("{}", i8::try_from(32i32).unwrap());
    // output: 32, panic if the value is not fit to i8.
    let i_8: i8 = 32i32.try_into().unwrap();
    println!("{}", i_8);
    // output: 32, panic if the value is not fit to i8.
}
From/Into
只能从小范围数类型变成大的数类型。安全。
也可以用于 str 和 String 之间的转换。
use std::convert::From;
use std::convert::Into;

fn from_into() {
    println!("{}", i32::from(127i8));
    // output: 127
    let i_32: i32 = 127i8.into();
    println!("{}", i_32);
    // output: 127
}
unsafe
// Cargo.toml
// [dependencies]
// rand = "0.8.3"
use rand::random;

fn unsafe_f64() {
    println!("{}", unsafe {
        f64::to_int_unchecked::<usize>(random::<f64>() * 100.0)
    });
    // output: 67
}
to_string/parse
用于字符串和数类型之间转换

fn to_string_parse() {
    // string -> float
    let s = "123.456";
    println!("{} ", s.parse::<f64>().unwrap());
    // output: 123.456

    // float -> string
    let f_64 = 123.456;
    println!("{} ", f_64.to_string());
    // output: 123.456

    // float -> string
    let f_64 = 123.456;
    println!("{} ", f_64.to_string());
    // output: 123.456
}

在日期和字符串之间转换
// Cargo.toml
// [dependencies]
// chrono = "0.4"
use chrono::*;

fn date_time() {
    let locale = Local.ymd(2020, 12, 05).and_hms(12, 0, 9);
    println!("{:?}", locale.format("%Y-%m-%d %H:%M:%S.%s").to_string());
    // "2020-12-05 12:00:09.1607140809"

    println!("{:?}", locale.format("%a %b %e %T %Y").to_string());
    // "Sat Dec  5 12:00:09 2020"

    println!("{:?}", locale.format("%c").to_string());
    // "Sat Dec  5 12:00:09 2020"

    println!("{:?}", locale.to_string());
    // "2020-12-05 12:00:09 +08:00"

    println!("{:?}", locale.to_rfc2822());
    // "Sat, 05 Dec 2020 12:00:09 +0800"

    println!("{:?}", locale.to_rfc3339());
    // "2020-12-05T12:00:09+08:00"

    let date_str = "2020-04-12 22:10:57";
    let naive_datetime = NaiveDateTime::parse_from_str(date_str, "%Y-%m-%d %H:%M:%S").unwrap();
    println!("{:?}", naive_datetime.to_string());
    // "2020-04-12 22:10:57"

    let date_str = "2020-04-12 22:10:57 +02:00";
    let datetime = DateTime::parse_from_str(date_str, "%Y-%m-%d %H:%M:%S %z").unwrap();
    println!("{:?}", datetime.to_string());
    // "2020-04-12 22:10:57 +02:00"

    let date_str = "2020-04-12";
    let naive_date = NaiveDate::parse_from_str(date_str, "%Y-%m-%d").unwrap();
    println!("{:?}", naive_date.to_string());
    // "2020-04-12"

    let time_str = "22:10:57";
    let naive_time = NaiveTime::parse_from_str(time_str, "%H:%M:%S").unwrap();
    println!("{:?}", naive_time.to_string());
    // "22:10:57"
}
```

## 格式化输出

```rust
print!将格式化文本输出到控制台，不带换行符。
println!将格式化文本输出到控制到，末尾加一个换行符。
format!将格式化文本输出到字符串。

print!("{}.print is output to console w/o newline.", 1);
print!("Continue...");
print!("n");
println!("{}.println is string to console w/ newline.", 2);
let str = format!("{}.format is output to a string.", 3);
assert_eq!(str, "3.format is output to a string.");
println!("{}", str);

println!("{}, {}", "Hello", "world");
println!("{0}, this is {1}. {1}, this is {0}.", "Hellen", "Tom");
println!("{subject} {verb} {object}", object="the lazy dog", subject="the quick brwon fox", verb="jumps over");

https://www.dazhuanlan.com/sjmr/topics/1380459
```

## special format

| * 数字       | Rust 格式    | Python 格式    | 输出               | 描述 *                        |
| ------------ | ------------ | -------------- | ------------------ | ----------------------------- |
| 3.1415926    | {:.2}        | {:.2f}         | 3.14               | 保留小数点后两位              |
| 3.1415926    | {:+.2}       | {:+.2f}        | +3.14              | 带符号保留小数点后两位        |
| -1           | {:+.2}       | {:+.2f}        | -1(R)/-1.00(P)     | 带符号保留小数点后两位        |
| -1.0         | {:+.2}       | {:+.2f}        | -1.00              | 带符号保留小数点后两位        |
| 2.71828      | {:.0}}       | {:.0f}         | 3                  | 不带小数                      |
| 5            | {:0>2}/{:02} | {:0>2d}/{:02d} | 05                 | 数字补 0 (填充左边, 宽度为 2) |
| 5            | {:x^10}      | {:x^10d}       | xxxx5xxxxx         | 居中对齐                      |
| 5            | {:x<4}       | {:x<4d}        | 5xxx               | 数字补 x (填充右边, 宽度为 4) |
| 1000000      | NA.          | {:,}           | 1,000,000          | 以逗号分隔的数字格式          |
| 0.25         | NA.          | {:.2%}         | 25.00%             | 百分比格式                    |
| 1000000000   | NA.          | {:.2e}         | 1.00e+09           | 指数记法                      |
| 1000000000.0 | {:2e}        | {:.2e}         | 1e9(R)/1.00e+09(P) | 指数记法                      |
| 1000000000.0 | {:2E}        | {:.2E}         | 1E9(R)/1.00E+09(P) | 指数记法                      |
| 42           | {:b}         | {:b}           | 101010             | 二进制                        |
| 42           | {:o}         | {:o}           | 52                 | 八进制                        |
| 42           | {:x}         | {:x}           | 2a                 | 十六进制                      |
| 42           | {:X}         | {:X}           | 2A                 | 十六进制                      |
| 42           | {:#b}        | {:#b}          | 0b101010           | 带前缀的二进制                |
| 42           | {:#o}        | {:#o}          | 0o52               | 带前缀的八进制                |
| 42           | {:#x}        | {:#x}          | 0x2a               | 带前缀的十六进制              |
| 42           | {:#X}        | {:#X}          | 0x2A(R)/0X2A(P)    | 带前缀的十六进制              |

Rust precision specified in arg

```
println!("Pi is {:+.*}", 2, 3.1415926);
```

## 路径来引用模块树中的项

```rust
路径来引用模块树中的项
如果想要调用函数，需要知道其路径。
路径有两种形式：


绝对路径从crate 根开始，以 crate 名或者字面值 crate开头

相对路径从当前模块开始，以self、supper或者当前模块的标识符开头。

绝对路径和相对路径都后跟一个或多个由双冒号(::)分割的标识符。

作者：kaiv2
链接：https://www.jianshu.com/p/51693602114a/
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。
```

## 关于Rust读取自定义toml文件

-   思路，关于自定义的toml文件应该有一定配置规则，不清楚或者不了解**toml**文件配置的[点击这个链接](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Ftoml-lang%2Ftoml)

-   知道**toml**的使用后，配置对应的配置选项，然后利用程序读取配置达到我们文件可动态配置的目的（下面这是对于toml配置的演示）

    

    ```toml
    [[ip_config]]
    name="CN"
    ip="192.168.1.1"
    port="11"
    
    [[ip_config]]
    name="TW"
    ip="192.168.2.2"
    port="22"
    
    [[ip_config]]
    name="JP"
    ip="192.168.3.3"
    port="33"
    ```

-   如果有了类似配置后，大致是一下几步：

    -   ①我们只需要读取该文件到对应内存
    -   ②然后构造对应数据结构
    -   ③序列化

    ok，我们下面来试试吧。

### 准备前

-   因为使用到toml文件，因此我们需要引用到第三方依赖，需要下面三个依赖 ，后两者是序列化用的

    -   [https://crates.io/crates/toml](https://link.jianshu.com/?t=https%3A%2F%2Fcrates.io%2Fcrates%2Ftoml)
    -   [https://crates.io/crates/serde](https://link.jianshu.com/?t=https%3A%2F%2Fcrates.io%2Fcrates%2Fserde)
    -   [https://crates.io/crates/serde_derive](https://link.jianshu.com/?t=https%3A%2F%2Fcrates.io%2Fcrates%2Fserde_derive)

    

    ```rust
    [dependencies]
    toml = "0.4.5"
    serde_derive = "1.0.32"
    serde = "1.0.32"
    ```

### 定义toml文件



```toml
    [[ip_config]]
    name="CN"
    ip="192.168.1.1"
    port="11"

    [[ip_config]]
    name="TW"
    ip="192.168.2.2"
    port="22"

    [[ip_config]]
    name="JP"
    ip="192.168.3.3"
    port="33"
```

### 构造数据结构



```rust
    struct IpConfig {
        name: Option<String>,
        ip: Option<String>,
        port: Option<String>
    }
    
    struct Conf
    {
        ip_config: Option<Vec<IpConfig>>
    }
    
```

### 读取文件到内存，序列化



```rust
#[macro_use]
extern crate serde_derive;
extern crate toml;

use std::fs::File;
use std::io::prelude::*;

#[derive(Deserialize)]
#[derive(Debug)]
struct IpConfig {
    name: Option<String>,
    ip: Option<String>,
    port: Option<String>,
}

#[derive(Deserialize)]
#[derive(Debug)]
struct Conf
{
    ip_config: Option<Vec<IpConfig>>
}

fn main() {
    let file_path = "config.toml";
    let mut file = match File::open(file_path) {
        Ok(f) => f,
        Err(e) => panic!("no such file {} exception:{}", file_path, e)
    };
    let mut str_val = String::new();
    match file.read_to_string(&mut str_val) {
        Ok(s) => s
        ,
        Err(e) => panic!("Error Reading file: {}", e)
    };
    let config: Conf = toml::from_str(&str_val).unwrap();

    for x in config.ip_config.unwrap() {
        println!("{:?}", x);
    }
}
```

ok，到此，自定义toml文件内容就加载到 **config** 中来了，打印出数据分别是



```rust
IpConfig { name: Some("CN"), ip: Some("192.168.1.1"), port: Some("11") }
IpConfig { name: Some("TW"), ip: Some("192.168.2.2"), port: Some("22") }
IpConfig { name: Some("JP"), ip: Some("192.168.3.3"), port: Some("33") }
```

项目链接地址：[https://github.com/baoyachi/read-toml](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fbaoyachi%2Fread-toml)

## Struct和Enum的私有性

Struct和Enum的私有性略有不同，对于Struct来讲，我可以只将其中的某些字段设置为公有的，其他字段可以仍然保持私有。

```rust
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);
}
```

而对于Enum，如果一个Enum是公有的，那么它的所有值都是公有的，因为私有的值没有意义。

## 扩展配置文件读取

```rust
先定义通用文件读取以及文件访问接口
// 文件读取统一接口
pub trait ConfReadImpl {
    // path: 文件路径
    fn read_conf(&mut self, path: &str) -> Result<i32, Error>;
}

// 获取读取后的值
pub trait GetConfImpl {
    fn get_string(&self, key: &str) -> String;
    fn def_get_i32(&self, key: &str, def: i32) -> i32;
    fn def_get_u32(&self, key: &str, def: u32) -> u32;
    fn def_get_f32(&self, key: &str, def: f32) -> f32;
    fn def_get_f64(&self, key: &str, def: f64) -> f64;
    fn def_get_bool(&self, key: &str, def: bool) -> bool;

    fn get_i32(&self, key: &str) -> i32;
    fn get_u32(&self, key: &str) -> u32;
    fn get_f32(&self, key: &str) -> f32;
    fn get_f64(&self, key: &str) -> f64;
    fn get_bool(&self, key: &str) -> bool;
}


定义统一调用文件方式
// 定义统一对外访问接口
pub trait ConfImpl: GetConfImpl + ConfReadImpl{}
// 给实现了GetConfImpl 和ConfReadImpl 的类型默认实现ConfImpl
impl <T> ConfImpl for T  where T: GetConfImpl + ConfReadImpl {}

pub struct Conf {
    conf_map: HashMap<String, Box<dyn ConfImpl>>,
}

impl Conf {
    pub fn new () -> Self {
        Self {
            conf_map: HashMap::new(),
        }
    }
}

impl Conf {
     // 初始化配置
     pub fn init(&mut self, key: &str, path: &str) -> &Box<dyn ConfImpl> {
         self.read_conf(key, path);
         return self.conf_map.get(key).unwrap();
     }

     // 初始化配置 - 读取配置文件
    fn read_conf(&mut self, key: &str, path: &str) {
        // 防止多次调用
        if self.conf_map.is_empty() {
            self.register_conf();
        } else {
            return;
        }

        if !self.conf_map.contains_key(key) {
            panic!("不存在指定的功能模块");
        }

        let conf = self.conf_map.get_mut(key).unwrap();
        // 读取文件
        let new_conf = conf.as_mut();
        if let Err(e) = new_conf.read_conf(path) {
            panic!(e);
        }
    }

    // 注册配置文件读取器 - 这一步是手动的
    fn register_conf(&mut self) {
        self.conf_map.insert("ini".to_string(), Box::new(ConfIni::new()));
    }
}

调用
fn main() {
    let mut conf = Conf::new();
    let new_conf = conf.init("ini", "web/app.conf");

    println!("{}", new_conf.get_string("server::test"));
    println!("{}", new_conf.get_string("my_str"));
}

```

## 大小写转换

```rust
convert_case = "0.4.0"

use convert_case::{Case, Casing};

assert_eq!("Ronnie James Dio", "ronnie james dio".to_case(Case::Title));
assert_eq!("ronnieJamesDio", "Ronnie_James_dio".to_case(Case::Camel));
assert_eq!("Ronnie-James-Dio", "RONNIE_JAMES_DIO".to_case(Case::Train));

assert_eq!(
    "2020 04 16 My Cat Cali",
    "2020-04-16_my_cat_cali".to_case(Case::Title)
);
assert_eq!(
    "2020-04-16 My Cat Cali",
    "2020-04-16_my_cat_cali".from_case(Case::Snake).to_case(Case::Title)
);

assert_eq!("io_stream", "IOStream".to_case(Case::Snake));
assert_eq!("my_json_parser", "myJSONParser".to_case(Case::Snake));

assert_eq!("weird_var_name", "__weird--var _name-".to_case(Case::Snake));

assert_eq!("granat-äpfel", "GranatÄpfel".to_case(Case::Kebab));

// The example from str::to_lowercase documentation
let odysseus = "ὈΔΥΣΣΕΎΣ";
assert_eq!("ὀδυσσεύς", odysseus.to_case(Case::Lower));

assert_eq!("e_5150", "E5150".to_case(Case::Snake));
assert_eq!("10,000_days", "10,000Days".to_case(Case::Snake));
assert_eq!("HELLO, WORLD!", "Hello, world!".to_case(Case::Upper));//大写
assert_eq!("One\ntwo\nthree", "ONE\nTWO\nTHREE".to_case(Case::Title));

// Mistakenly parsing using Case::Snake
assert_eq!("My-kebab-var", "my-kebab-var".from_case(Case::Snake).to_case(Case::Title));

// Converts using an unexpected method
assert_eq!("my_kebab_like_variable", "myKebab-like-variable".to_case(Case::Snake));



//将此字符串就地转换为其等效的ASCII大写字母。ASCII字母“a”到“z”映射到“a”到“z”，但非ASCII字母不变。
let value: String;
value.make_ascii_uppercase()
```

## Redis

```rust
由于 redis 本质上大多是无类型的，并且协议对开发人员并不完全友好，因此此库为将值转换为预期结果提供了灵活的支持。这是通过 和 特征驱动的。FromRedisValueToRedisArgs

命令的方法将通过特征接受各种类型，命令的方法可以将值转换为您希望函数通过特征返回的值。这是非常灵活的，允许向量，元组，哈希集，哈希映射以及可选值：argToRedisArgsqueryFromRedisValue

let count : i32 = con.get("my_counter")?;
let count = con.get("my_counter").unwrap_or(0i32);
let k : Option<String> = con.get("missing_key")?;
let name : String = con.get("my_name")?;
let bin : Vec<u8> = con.get("my_binary")?;
let map : HashMap<String, i32> = con.hgetall("my_hash")?;
let keys : Vec<String> = con.hkeys("my_hash")?;
let mems : HashSet<i32> = con.smembers("my_set")?;
let (k1, k2) : (String, String) = con.get(&["k1", "k2"])?;


迭代协议

除了发送单个查询外，还支持迭代器。当与常规批量响应一起使用时，它们不会给你太多的查询和转换为向量（两者都在内部使用向量），但它们也可以与类似命令一起使用，在这种情况下，迭代将发送更多查询，直到光标耗尽：SCAN

let mut iter : redis::Iter<isize> = redis::cmd("SSCAN").arg("my_set")
    .cursor_arg(0).clone().iter(&mut con)?;
for x in iter {
    // do something with the item
}

///---------------------------------------------------------
除了简单的查询之外，您还可以发送命令管道。这是通过该函数提供的。它的工作原理与发送单个命令非常相似，但您可以一次性发送多个命令。这还允许您忽略单个结果，以便更容易匹配最终结果：pipe
let (k1, k2) : (i32, i32) = redis::pipe()
    .cmd("SET").arg("key_1").arg(42).ignore()
    .cmd("SET").arg("key_2").arg(43).ignore()
    .cmd("GET").arg("key_1")
    .cmd("GET").arg("key_2").query(&mut con)?;


如果希望将管道包装在 / 块中，则可以通过将管道切换到模式来轻松执行此操作。从调用方的角度来看，没有任何变化，管道本身将为您处理其余部分：MULTIEXECatomic
let (k1, k2) : (i32, i32) = redis::pipe()
    .atomic()
    .cmd("SET").arg("key_1").arg(42).ignore()
    .cmd("SET").arg("key_2").arg(43).ignore()
    .cmd("GET").arg("key_1")
    .cmd("GET").arg("key_2").query(&mut con)?;

您还可以在管道上使用高级命令：
let (k1, k2) : (i32, i32) = redis::pipe()
    .atomic()
    .set("key_1", 42).ignore()
    .set("key_2", 43).ignore()
    .get("key_1")
    .get("key_2").query(&mut con)?;
//-----------------------------------------------------------------


Pubsub 当前正在进行中，但通过连接对象提供。由于 Rust 在 libnative 中尚不支持异步 IO，因此 API 尚未提供读取具有任何形式超时的消息的方法。PubSub

用法示例：

let client = redis::Client::open("redis://127.0.0.1/")?;
let mut con = client.get_connection()?;
let mut pubsub = con.as_pubsub();
pubsub.subscribe("channel_1")?;
pubsub.subscribe("channel_2")?;

loop {
    let msg = pubsub.get_message()?;
    let payload : String = msg.get_payload()?;
    println!("channel '{}': {}", msg.get_channel_name(), payload);
}


除了上面已经解释过的同步接口之外，还存在一个基于futures和tokio的异步接口。

此接口存在于 （async io） 模块下，并且在很大程度上反映了同步，并做出了一些让步，以使其符合 的约束。aiofutures

use futures::prelude::*;
use redis::AsyncCommands;

let client = redis::Client::open("redis://127.0.0.1/").unwrap();
let mut con = client.get_async_connection().await?;

con.set("key1", b"foo").await?;

redis::cmd("SET").arg(&["key2", "bar"]).query_async(&mut con).await?;

let result = redis::cmd("MGET")
 .arg(&["key1", "key2"])
 .query_async(&mut con)
 .await;
assert_eq!(result, Ok(("foo".to_string(), b"bar".to_vec())));
```

## 线程通讯 - channel

```rust
use std::thread;
use std::sync::mpsc;  //一个通道可以有多个发送端，只能有一个接收端

fn main() {
    let (tx, rx) = mpsc::channel();  //建立通道，获取tuple元素，发送者，接收者

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();  //tx搬家，rx还在主线程
        println!("val is {}", val);  //不可以，val已经转移
    });

    let received = rx.recv().unwrap();  //可以处理Result<T, E>
    //recv()阻塞，等待消息；try_recv()不阻塞，立刻返回，可用循环查收
    println!("Got: {}", received);
}


接收多个消息
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {  //作为迭代器
        println!("Got: {}", received);
    }
}

多发单收
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&tx);  //同一通道，增加一个发送者

thread::spawn(move || {
    let vals = vec![
        String::from("hi"),
        String::from("from"),
        String::from("the"),
        String::from("thread"),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from("more"),
        String::from("messages"),
        String::from("for"),
        String::from("you"),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {  //一个通道一个接收者，接收两个线程的两个发送者
    println!("Got: {}", received);
}

// --snip--
}
```

## trait与泛型

我们了解了Rust中trait的定义和使用，接下来我们介绍一下它的使用场景，从中我们可以窥探出接口这特性带来的惊喜

我们知道泛型可以指任意类型，但有时这不是我们想要的，需要给它一些约束。

#### 泛型的trait约束

```rust
use std::fmt::Debug;
fn foo<T: Debug>(s: T) {
	println!("{:?}", s);
}
Debug`是**Rust**内置的一个trait，为”{:?}”实现打印内容，函数`foo`接受一个泛型作为参数，并且约定其需要实现`Debug
```

## 迭代器

```rust
消费者与适配器
说完了for循环，我们大致弄清楚了 Iterator 和 IntoIterator 之间的关系。下面我们来说一说消费者和适配器。

消费者是迭代器上一种特殊的操作，其主要作用就是将迭代器转换成其他类型的值，而非另一个迭代器。

而适配器，则是对迭代器进行遍历，并且其生成的结果是另一个迭代器，可以被链式调用直接调用下去。

```

## 智能指针

### Rc

```rust
Rc 用于同一线程内部，通过 use std::rc::Rc 来引入。它有以下几个特点：

用 Rc 包装起来的类型对象，是 immutable 的，即 不可变的。即你无法修改 Rc<T> 中的 T 对象，只能读；
一旦最后一个拥有者消失，则资源会被自动回收，这个生命周期是在编译期就确定下来的；
Rc 只能用于同一线程内部，不能用于线程之间的对象共享（不能跨线程传递）；
Rc 实际上是一个指针，它不影响包裹对象的方法调用形式（即不存在先解开包裹再调用值这一说）。
例子：

use std::rc::Rc;
let five = Rc::new(5);
let five2 = five.clone();
let five3 = five.clone();


Rc Weak
Weak 通过 use std::rc::Weak 来引入。

Rc 是一个引用计数指针，而 Weak 是一个指针，但不增加引用计数，是 Rc 的 weak 版。它有以下几个特点：

可访问，但不拥有。不增加引用计数，因此，不会对资源回收管理造成影响；
可由 Rc<T> 调用 downgrade 方法而转换成 Weak<T>；
Weak<T> 可以使用 upgrade 方法转换成 Option<Rc<T>>，如果资源已经被释放，则 Option 值为 None；
常用于解决循环引用的问题。
例子：

use std::rc::Rc;
let five = Rc::new(5);
let weak_five = Rc::downgrade(&five);
let strong_five: Option<Rc<_>> = weak_five.upgrade();
```

### Arc

```rust
Arc 是原子引用计数，是 Rc 的多线程版本。Arc 通过 std::sync::Arc 引入。

它的特点：

Arc 可跨线程传递，用于跨线程共享一个对象；
用 Arc 包裹起来的类型对象，对可变性没有要求；
一旦最后一个拥有者消失，则资源会被自动回收，这个生命周期是在编译期就确定下来的；
Arc 实际上是一个指针，它不影响包裹对象的方法调用形式（即不存在先解开包裹再调用值这一说）；
Arc 对于多线程的共享状态几乎是必须的（减少复制，提高性能）。
示例：

use std::sync::Arc;
use std::thread;
fn main() {
let numbers: Vec<_> = (0..100u32).collect();
let shared_numbers = Arc::new(numbers);
for _ in 0..10 {
let child_numbers = shared_numbers.clone();
thread::spawn(move || {
let local_numbers = &child_numbers[..];
// Work with the local numbers
});
}
}
Arc Weak
与 Rc 类似，Arc 也有一个对应的 Weak 类型，从 std::sync::Weak 引入。

意义与用法与 Rc Weak 基本一致，不同的点是这是多线程的版本。故不再赘述。

一个例子
下面这个例子，表述的是如何实现多个对象同时引用另外一个对象。

use std::rc::Rc;
struct Owner {
name: String
}
struct Gadget {
id: i32,
owner: Rc<Owner>
}
fn main() {
// Create a reference counted Owner.
let gadget_owner : Rc<Owner> = Rc::new(
Owner { name: String::from("Gadget Man") }
);
// Create Gadgets belonging to gadget_owner. To increment the reference
// count we clone the `Rc<T>` object.
let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };
let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };
drop(gadget_owner);
// Despite dropping gadget_owner, we're still able to print out the name
// of the Owner of the Gadgets. This is because we've only dropped the
// reference count object, not the Owner it wraps. As long as there are
// other `Rc<T>` objects pointing at the same Owner, it will remain
// allocated. Notice that the `Rc<T>` wrapper around Gadget.owner gets
// automatically dereferenced for us.
println!("Gadget {} owned by {}", gadget1.id, gadget1.owner.name);
println!("Gadget {} owned by {}", gadget2.id, gadget2.owner.name);
// At the end of the method, gadget1 and gadget2 get destroyed, and with
// them the last counted references to our Owner. Gadget Man now gets
// destroyed as well.
}
```

### Mutex

```rust
Mutex 意为互斥对象，用来保护共享数据。Mutex 有下面几个特征：

Mutex 会等待获取锁令牌(token)，在等待过程中，会阻塞线程。直到锁令牌得到。同时只有一个线程的 Mutex 对象获取到锁；
Mutex 通过 .lock() 或 .try_lock() 来尝试得到锁令牌，被保护的对象，必须通过这两个方法返回的 RAII 守卫来调用，不能直接操作；
当 RAII 守卫作用域结束后，锁会自动解开；
在多线程中，Mutex 一般和 Arc 配合使用。
示例：

use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc::channel;
const N: usize = 10;
// Spawn a few threads to increment a shared variable (non-atomically), and
// let the main thread know once all increments are done.
//
// Here we're using an Arc to share memory among threads, and the data inside
// the Arc is protected with a mutex.
let data = Arc::new(Mutex::new(0));
let (tx, rx) = channel();
for _ in 0..10 {
    let (data, tx) = (data.clone(), tx.clone());
    thread::spawn(move || {
        // The shared state can only be accessed once the lock is held.
        // Our non-atomic increment is safe because we're the only thread
        // which can access the shared state when the lock is held.
        //
        // We unwrap() the return value to assert that we are not expecting
        // threads to ever fail while holding the lock.
        let mut data = data.lock().unwrap();
        *data += 1;
        if *data == N {
            tx.send(()).unwrap();
        }
        // the lock is unlocked here when `data` goes out of scope.
    });
}

rx.recv().unwrap();
lock 与 try_lock 的区别
.lock() 方法，会等待锁令牌，等待的时候，会阻塞当前线程。而 .try_lock() 方法，只是做一次尝试操作，不会阻塞当前线程。

当 .try_lock() 没有获取到锁令牌时，会返回 Err。因此，如果要使用 .try_lock()，需要对返回值做仔细处理（比如，在一个循环检查中）。

点评：Rust 的 Mutex 设计成一个对象，不同于 C 语言中的自旋锁用两条分开的语句的实现，更安全，更美观，也更好管理。
```



### RwLock

```rust
RwLock 翻译成 读写锁。它的特点是：

同时允许多个读，最多只能有一个写；
读和写不能同时存在；
比如：

use std::sync::RwLock;
let lock = RwLock::new(5);
// many reader locks can be held at once
{
let r1 = lock.read().unwrap();
let r2 = lock.read().unwrap();
assert_eq!(*r1, 5);
assert_eq!(*r2, 5);
} // read locks are dropped at this point
// only one write lock may be held, however
{
let mut w = lock.write().unwrap();
*w += 1;
assert_eq!(*w, 6);
} // write lock is dropped here
读写锁的方法
.read()
.try_read()
.write()
.try_write()
注意需要对 .try_read() 和 .try_write() 的返回值进行判断。
```

具体是因为，它们提供了 `内部可变性`（相对于标准的 `继承可变性` 来讲的）。

通常，我们要修改一个对象，必须

1.  成为它的拥有者，并且声明 `mut`；
2.  或 以 `&mut` 的形式，借用；

而通过 `Cell`, `RefCell`，我们可以在需要的时候，就可以修改里面的对象。而不受编译期静态借用规则束缚。

### Cell

```rust
Cell 有如下特点：

Cell<T> 只能用于 T 实现了 Copy 的情况；
.get()
    .get() 方法，返回内部值的一个拷贝。比如：

use std::cell::Cell;
let c = Cell::new(5);
let five = c.get();

.set()
    .set() 方法，更新值。

use std::cell::Cell;
let c = Cell::new(5);
c.set(10);
```

### RefCell

```rust
相对于 Cell 只能包裹实现了 Copy 的类型，RefCell 用于更普遍的情况（其它情况都用 RefCell）。

相对于标准情况的 静态借用，RefCell 实现了 运行时借用，这个借用是临时的。这意味着，编译器对 RefCell 中的内容，不会做静态借用检查，也意味着，出了什么问题，用户自己负责。

RefCell 的特点：

//在不确定一个对象是否实现了 Copy 时，直接选 RefCell；
如果被包裹对象，同时被可变借用了两次，则会导致线程崩溃。所以需要用户自行判断；
RefCell 只能用于线程内部，不能跨线程；
RefCell 常常与 Rc 配合使用（都是单线程内部使用）；
我们来看实例：

use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;
fn main() {
let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));
shared_map.borrow_mut().insert("africa", 92388);
shared_map.borrow_mut().insert("kyoto", 11837);
shared_map.borrow_mut().insert("piccadilly", 11826);
shared_map.borrow_mut().insert("marbles", 38);
}
从上例可看出，用了 RefCell 后，外面是 不可变引用 的情况，一样地可以修改被包裹的对象。

常用方法

.borrow()
不可变借用被包裹值。同时可存在多个不可变借用。

比如：

use std::cell::RefCell;
let c = RefCell::new(5);
let borrowed_five = c.borrow();
let borrowed_five2 = c.borrow();
下面的例子会崩溃：

use std::cell::RefCell;
use std::thread;
let result = thread::spawn(move || {
let c = RefCell::new(5);
let m = c.borrow_mut();
let b = c.borrow(); // this causes a panic
}).join();
assert!(result.is_err());
.borrow_mut()
可变借用被包裹值。同时只能有一个可变借用。

比如：

use std::cell::RefCell;
let c = RefCell::new(5);
let borrowed_five = c.borrow_mut();
下面的例子会崩溃：

use std::cell::RefCell;
use std::thread;
let result = thread::spawn(move || {
let c = RefCell::new(5);
let m = c.borrow();
let b = c.borrow_mut(); // this causes a panic
}).join();
assert!(result.is_err());
.into_inner()
取出包裹值。

use std::cell::RefCell;
let c = RefCell::new(5);
let five = c.into_inner();
```



```rust
一个综合示例
下面这个示例，表述的是如何实现两个对象的循环引用。综合演示了 Rc, Weak, RefCell 的用法

use std::rc::Rc;
use std::rc::Weak;
use std::cell::RefCell;
struct Owner {
name: String,
gadgets: RefCell<Vec<Weak<Gadget>>>,
// 其他字段
}
struct Gadget {
id: i32,
owner: Rc<Owner>,
// 其他字段
}
fn main() {
// 创建一个可计数的Owner。
// 注意我们将gadgets赋给了Owner。
// 也就是在这个结构体里， gadget_owner包含gadets
let gadget_owner : Rc<Owner> = Rc::new(
Owner {
name: "Gadget Man".to_string(),
gadgets: RefCell::new(Vec::new()),
}
);
// 首先，我们创建两个gadget，他们分别持有 gadget_owner 的一个引用。
let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});
let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});
// 我们将从gadget_owner的gadgets字段中持有其可变引用
// 然后将两个gadget的Weak引用传给owner。
gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget1));
gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget2));
// 遍历 gadget_owner的gadgets字段
for gadget_opt in gadget_owner.gadgets.borrow().iter() {
// gadget_opt 是一个 Weak<Gadget> 。 因为 weak 指针不能保证他所引用的对象
// 仍然存在。所以我们需要显式的调用 upgrade() 来通过其返回值(Option<_>)来判
// 断其所指向的对象是否存在。
// 当然，这个Option为None的时候这个引用原对象就不存在了。
let gadget = gadget_opt.upgrade().unwrap();
println!("Gadget {} owned by {}", gadget.id, gadget.owner.name);
}
// 在main函数的最后， gadget_owner, gadget1和daget2都被销毁。
// 具体是，因为这几个结构体之间没有了强引用（`Rc<T>`），所以，当他们销毁的时候。
// 首先 gadget1和gadget2被销毁。
// 然后因为gadget_owner的引用数量为0，所以这个对象可以被销毁了。
// 循环引用问题也就避免了
}
```



如果一个参数可以多个结构体的话,可以使用实现trait,来约束

## 减少rust编译后程序体积

```rust
第一步：
编译 release 版本

cargo build --release
第二步：
strip 命令

strip -s target/release/testGui
扩展
整优化等级
通过修改默认优化等级方式减少体积，以cpu换空间，如果不是必要，建议不要改
在Cargo.toml中新增下面配置

[profile.release]
opt-level = 'z'
开启 LTO
减少体积，增加链接时间也是一个取舍问题
在Cargo.toml中新增下面配置


[profile.release]
lto = true

作者：StrangenessWind
链接：https://www.jianshu.com/p/279407cad24c
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## rust关键字定义变量

```rust
type
您可以通过在关键字前面加前缀来使用“原始标识符”，如：r#type。

您可能还希望在Rust代码中为其指定一个不同的名称，并使用#[serde(rename)]使其以名称“type”进行序列化，如：

struct Foo {
  #[serde(rename = "type")]
  kind: String
}
就我个人而言，我更喜欢第二种方式，因为我觉得r#type打字有点烦人和难看，但这只是偏好，没有“正确”的方式

use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize)]
struct Entry {
    #[serde(rename = "commonA")]
    common_a: i64,
    #[serde(rename = "commonB")]
    common_b: i64,
    #[serde(flatten)]
    variant: EntryVariant,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
enum EntryVariant {
    Foo(FooSpecific),
    Bar(BarSpecific),
}

#[derive(Debug, Serialize, Deserialize)]
struct FooSpecific {
    #[serde(rename = "fooSpecificA")]
    foo_specific_a: i64,
    #[serde(rename = "fooSpecificB")]
    foo_specific_b: i64,
}

#[derive(Debug, Serialize, Deserialize)]
struct BarSpecific {
    #[serde(rename = "barSpecificA")]
    bar_specific_a: i64,
    #[serde(rename = "barSpecificB")]
    bar_specific_b: i64,
}
```



## Rust文档注释

```rust
/// : 使用3条斜线 -> 生成文档 <html>
cargo doc //生成文档 <target/doc目录下>
cargo doc --open // 打开注释文档<通过浏览器打开>

```

## Rust读写锁

```rust
Rust中的读写锁RwLock
经典问题
读者-作家问题
基本概念
临界区 Critical section
互斥量 Mutex
信号量 Semaphore
读写锁 RWLock
Rust中的RwLock实现
std::sync::RwLock
parking_lot::RwLock
经典问题
在计算机科学中，有一些经典的同步问题，读者-作家问题就是其中一个，该问题涉及多个并发线程试图同时访问同一共享资源的情况。

读者-作家问题：我们拥有一种资源（例如，数据库），可以由不修改资源的读者和可以修改资源的作家访问。当作家修改资源时，其他任何人（读者或作家）都无法同时访问它，因为另一位作家可能破坏资源，而另一位读者可能读取部分修改的值，因此可能出现不一致。

基本概念
为了准确理解问题，我们先介绍一些基本概念。

临界区 Critical section，在并发编程中，对共享资源的并发访问可能导致意外或错误的行为，因此需要以某种方式保护访问共享资源的那部分程序。这部分受保护的代码片段称为临界区。

互斥量 Mutex，在多线程并发编程时，为了确保一次仅一个线程可以访问共享资源，引入了Mutex的概念，它是 Mutual Exclusion 的缩写，通常翻译为互斥量或互斥锁。

信号量 Semaphore，同样的，为了控制并发系统中多个线程对共享资源的访问，引入了Semaphore的概念，通常翻译为信号量。

读写锁 RWLock，在计算机科学中，读写锁是解决读者-作家问题的同步原语之一。读写锁允许读操作共享访问，而写操作则需要互斥访问。通常构造在互斥量和条件变量之上，或者构造在信号量之上。

Rust中的读写锁
自读者-作家问题提出以来，人们对它进行了广泛的研究，读写锁是解决读者-作家问题的方案之一，按照读写锁的锁定优先级策略分为以下三种：

赋予读者优先权：当前至少有一个读者正在访问资源时，也应允许新读者访问它。如果有作家在等待修改资源并且新的读者一直到来，这可能会导致作家饿死，因为只要有至少一个读者，就永远不会授予作家访问权限。
赋予作家优先权：在这里，读者可能会饿死。
不给予任何优先权：所有读者和作家都将按到达顺序被授予对资源的访问权限。如果在读者访问资源时作家到达，它将等待这些读者释放资源，然后对其进行修改。同时抵达的新读者将不得不等待。
标准库中的RwLock：

允许在任何时间点具有多个读者或最多一个作家。也就是说，RwLock允许任何数量的读者获取锁，只要作家未持有该锁即可。
相比之下，互斥锁不会区分获取锁的种类，因此会阻塞等待可用锁的所有线程。
锁定策略取决于操作系统的实现，也就是说它不能保证将使用任何特定的锁定策略
Windows和macOS，读者和作家公平排队
Linux，读者优先，作家会出现饥饿现象
同时，第三方库parking_lot中也实现了RwLock，它与标准库的RwLock的主要区别是：

其锁定策略是任务公平（task-fair），而不是未指定的平台默认值，避免出现读者作家饥饿现象。
仅需要1个字的空间，而标准库由于平台限制而将RwLock装箱。
该锁在出现紧急情况时通常会被释放，无“中毒”（poisoning）现象。
基本的使用，示例如下：

#[macro_use]
extern crate lazy_static;

use std::thread;
use std::sync::RwLock;
//use parking_lot::RwLock;

lazy_static! {
    pub static ref INC: RwLock<i32> = RwLock::new(0);
}

fn main() {
    let thread1 = thread::spawn(|| {
        for i in 1..10 {
            let mut w = INC.write().unwrap();
            //let mut w = INC.write();
            *w = *w + 1;
        }
    });

    let thread2 = thread::spawn(|| {
        for i in 1..10 {
            let mut w = INC.write().unwrap();
            //let mut w = INC.write();
            *w = *w + 1;
        }
    });

    thread1.join().unwrap();
    thread2.join().unwrap();

    let r = INC.read().unwrap();
    //let r = INC.read();
    println!("{}", *r); // 输出 18
}


一般项目中会有对全局配置文件的操作，示例如下：
#[macro_use]
extern crate lazy_static;

use std::sync::RwLock;

#[derive(Debug, Clone, Copy)]
pub struct MyConfig {
    pub debug: bool,
    pub info: &'static str,
}

lazy_static! {
    pub static ref CONFIG: RwLock<MyConfig> = RwLock::new(MyConfig { debug: false, info: "Some info" });
}

impl MyConfig {
    pub fn init(custom_debug: Option<bool>, custom_info: Option<&'static str>) -> Result<(), i32> {
        let mut w = CONFIG.write().unwrap();

        match (custom_debug , custom_info) {
            (Some(debug_value), Some(custom_info)) => *w = MyConfig { debug: debug_value, info: custom_info},
            _ => (),
        };

        Ok(())
    }

    pub fn global_config() -> MyConfig {
        let m = CONFIG.read().unwrap();
		// 返回配置的拷贝
        *m
    }
}


fn main() {
    let a = MyConfig::global_config();

    dbg!(a);

    MyConfig::init(Some(true), Some("Updated"));

    let a = MyConfig::global_config();

    dbg!(a);
}


[src/main.rs:39] a = MyConfig {
    debug: false,
    info: "Some info",
}
[src/main.rs:45] a = MyConfig {
    debug: true,
    info: "Updated",
}

Rust异步入门 https://mp.weixin.qq.com/s/aA89BBUfM6UJYUMkOoZrig

理解智能指针 https://mp.weixin.qq.com/s/NpH-fVA_SdjpYgYkktfT5A

如何理解Rust中的变与不变 https://mp.weixin.qq.com/s/s9Ac0xfpG-KeVgPAFG-fog
https://www.bookstack.cn/read/RustPrimer/rcarc-mutex.md

Mutex
Mutex 意为互斥对象，用来保护共享数据。Mutex 有下面几个特征：
Mutex 会等待获取锁令牌(token)，在等待过程中，会阻塞线程。直到锁令牌得到。同时只有一个线程的 Mutex 对象获取到锁；
Mutex 通过 .lock() 或 .try_lock() 来尝试得到锁令牌，被保护的对象，必须通过这两个方法返回的 RAII 守卫来调用，不能直接操作；
当 RAII 守卫作用域结束后，锁会自动解开；
在多线程中，Mutex 一般和 Arc 配合使用。


RwLock
RwLock 翻译成 读写锁。它的特点是：

同时允许多个读，最多只能有一个写；
读和写不能同时存在；
```



## rust枚举匹配值

```rust
fn main() {
    let number = 13;
    // 试一试 ^ 将不同的值赋给 `number`

    println!("Tell me about {}", number);
    match number {
        // 匹配单个值
        1 => println!("One!"),
        // 匹配多个值
        2 | 3 | 5 | 7 | 11 => println!("This is a prime"),
        // 匹配一个闭区间范围
        13...19 => println!("A teen"),
        // 处理其他情况
        _ => println!("Ain't special"),
    }

    let boolean = true;
    // match 也是一个表达式
    let binary = match boolean {
        // match 分支必须覆盖所有可能的值
        false => 0,
        true => 1,
        // 试一试 ^ 试着将其中一条分支注释掉
    };

    println!("{} -> {}", boolean, binary);
}

```

## 什么是异步编程？

```rust
大多数计算机程序的执行顺序与编写顺序相同。执行第一行，然后执行下一行，依此类推。使用同步编程时，当程序遇到无法立即完成的操作时，它将阻塞，直到操作完成。例如，建立 TCP 连接需要通过网络与对等方进行交换，这可能需要相当长的时间。在此期间，线程被阻塞。

使用异步编程时，无法立即完成的操作将暂停到后台。线程不会被阻塞，并且可以继续运行其他操作。操作完成后，任务将处于未暂停状态，并从中断的位置继续处理。我们之前的示例只有一个任务，因此在挂起时不会发生任何反应，但异步程序通常具有许多此类任务。

虽然异步编程可以导致更快的应用程序，但它通常会导致更复杂的程序。程序员需要跟踪异步操作完成后恢复工作所需的所有状态。从历史上看，这是一项繁琐且容易出错的任务。
```



# C

## 时间

```C
C库
time():
C 库函数 time_t time(time_t *seconds) 返回自纪元 Epoch（1970-01-01 00:00:00 UTC）起经过的时间，以秒为单位。
如果 seconds 不为空，则返回值也存储在变量 seconds 中。

//声明
time_t time(time_t *t)
//功能：获取时间1970年至今
//t:指向类型为time_t的对象指针，用来存储t的值
//返回值：以time_t对象返回当前日历时间

//例子：
#include <stdio.h>
#include <time.h>

int main ()
{
  time_t seconds;

  seconds = time(NULL);
  printf("自 1970-01-01 起的小时数 = %ld\n", seconds/3600);

  return(0);
}
//输出
自 1970-01-01 起的小时数 = 373711

ctime()：
C 库函数 char *ctime(const time_t *timer) 返回一个表示当地时间的字符串，当地时间是基于参数 timer。

返回的字符串格式如下： Www Mmm dd hh:mm:ss yyyy 其中，
Www 表示星期几，Mmm 是以字母表示的月份，dd 表示一月中的第几天，hh:mm:ss 表示时间，yyyy 表示年份。

//声明：
char *ctime(const time_t *timer)
//timer：指向time_t对象的指针，该对象包含一个日历时间
//返回值：返回一个C字符串，包含了可读格式的日期和时间信息

//例子：
#include <stdio.h>
#include <time.h>

int main ()
{
   time_t curtime;

   time(&curtime);

   printf("当前时间 = %s", ctime(&curtime));

   return(0);
}
//输出：
当前时间 = Mon Aug 13 08:23:14 2012

localtime()：
C 库函数 struct tm *localtime(const time_t *timer) 使用 timer 的值来填充 tm 结构。timer 的值被分解为 tm 结构，并用本地时区表示。

//声明
struct tm *localtime(const time_t *timer)
//timer：这是指向表示日历时间的 time_t 值的指针。
//返回值：返回指向 tm 结构的指针，该结构带有被填充的时间信息。
struct tm {
   int tm_sec;         /* 秒，范围从 0 到 59                */
   int tm_min;         /* 分，范围从 0 到 59                */
   int tm_hour;        /* 小时，范围从 0 到 23                */
   int tm_mday;        /* 一月中的第几天，范围从 1 到 31                    */
   int tm_mon;         /* 月份，范围从 0 到 11                */
   int tm_year;        /* 自 1900 起的年数                */
   int tm_wday;        /* 一周中的第几天，范围从 0 到 6                */
   int tm_yday;        /* 一年中的第几天，范围从 0 到 365                    */
   int tm_isdst;       /* 夏令时                        */    
};

//例子
#include <stdio.h>
#include <time.h>

int main ()
{
   time_t rawtime;
   struct tm *info;
   char buffer[80];

   time( &rawtime );

   info = localtime( &rawtime );
   printf("当前的本地时间和日期：%s", asctime(info));

   return(0);
}
//输出
当前的本地时间和日期：Thu Aug 23 09:12:05 2012
    
    
#include <iostream>
#include <stdio.h>
#include <time.h>
    
std::string GetSysTime(std::string fmt)
{   
      time_t tmptime;
      struct tm *nowtime;
      char timestr[30] = "";
      time(&tmptime);
      nowtime = localtime(&tmptime);
      //"%Y-%m-%d %H:%M:%S.000"
     if (fmt.empty()) fmt = "%Y-%m-%d";
      //if (fmt.empty()) fmt = "%Y-%m-%d %H:%M:%S";
     strftime(timestr, sizeof(timestr), fmt.c_str(), nowtime);
      return std::string(timestr); 
  } 
int main ()
 {
     std::string Ttime;
     Ttime = GetSysTime("%Y%m%d");
     std::cout << Ttime << std::endl;
     printf("Time = %s\n",Ttime.c_str());
     
     long long t = 0;
     time_t tt = time(NULL);
     t = tt -15*60;
     printf("tt = %lld\n t = %lld\n",tt,t);
     struct tm s;
     localtime_r(&tt,&s);
     printf("%d",s.tm_year);//121
     printf("%lld",(s.tm_year+1900) * 10000000000 + (s.tm_mon + 1) * 100000000 + s.tm_mday * 1000000 + s.tm_hour*10000 + s.tm_min * 100);///20211111163300
 }
```

# C++

```C++
项目1:  awesome-cpp
    Tensorflow(机器学习框架)
    数据结构:github.com/TheAlgorithms/C/tree/master/data_structures
        	github.com/TheAlgorithms/C-plus-Plus
        Mzzopublic/C/tree/master
```



## 字符串

```C++
substr()是C++语言函数，主要功能是复制子字符串，要求从指定位置开始，并具有指定的长度。如果没有指定长度_Count或_Count+_Off超出了源字符串的长度，则子字符串将延续到源字符串的结尾。
    
    
 string中 find()的应用  （rfind() 类似，只是从反向查找）
原型如下：
（1）size_t find (const string& str, size_t pos = 0) const;  //查找对象--string类对象
（2）size_t find (const char* s, size_t pos = 0) const; //查找对象--字符串
（3）size_t find (const char* s, size_t pos, size_t n) const;  //查找对象--字符串的前n个字符
（4）size_t find (char c, size_t pos = 0) const;  //查找对象--字符
结果：找到 -- 返回 第一个字符的索引
     没找到--返回   string::npos

#include <iostream>
#include <string>
using namespace std;


 
int main()
{
	 //find函数返回类型size_type
	string s = "1a2b3c4d5e6f7g8h9i1a2b3c4d5e6f7g8ha9i";
	string flag;
	string::size_type position;
 
	//find函数返回 jk 在 s 中的下标位置
	position = s.find("jk");
	// 如果没找到，返回一个特别的标志
	// c++中用npos表示，我这里npos取值是4294967295
	if(position != s.npos)
	{
		cout << "position: " << position << endl;
	}
	else
	{
		cout << "Not found the flag" << endl;
	}
 
 
 
	//find函数返回 flag 中任意字符在 s 中第一次出现的下标位置
	flag = "c";
	position = s.find_first_of(flag);
	cout << "s.find_first_of(flag): " << position << endl;
 
 
 
    //从字符串 s 下标5开始，查找字符串 b ,返回 b 在s 中的下标
    position=s.find("b", 5);
    cout << "s.find(b,5): "<< position << endl;
 
    //查找 s 中 flag 出现的所有位置。
	flag = "a";
	position = 0;
	int i = 1;
	while((position = s.find_first_of(flag, position)) != string::npos)
	{
		cout << "position "<< i << " : "<< position << endl;
		position++;
		i++;
	}
 
 
    //查找 flag 中与 s 第一个不匹配的位置
    //flag.find_first_not_of(s)查找flag中含有s中任意字母的索引
    flag = "acb12389efgxyz789";
    position = flag.find_first_not_of(s);
    cout << "flag.find_first_not_of(s): "<< position << endl;
 
 
	//反向查找 flag 在s 中最后出现的位置
	flag = "3";
	position = s.rfind (flag);
	cout << "s.rfind(flag): "<< position <<endl;
 
	return 0;
}


basic_string substr( size_type _Off = 0,size_type _Count = npos) const;

_Off：所需的子字符串的起始位置。 字符串中第一个字符的索引为 0,默认值为0.

_Count：复制的字符数目

返回值：一个子字符串，从其指定的位置开始



std::vector<std::string> split(const std::string &str) {
    if (str.empty()) {
        return {};
    }
    std::vector<std::string> result;
    
    std::string::size_type pos = 0;
    std::string::size_type idx = 0;
    while (true) {
        pos = str.find(':', idx);
        if (pos == std::string::npos) {
            result.push_back(str.substr(idx));
            break;
        }

        result.push_back(str.substr(idx, pos - idx));
        idx = pos + 1;
    }

    return result;
}
```

```c++
  basic_string &append( const basic_string &str );
  basic_string &append( const char *str );
  basic_string &append( const basic_string &str, size_type index, size_type len );
  basic_string &append( const char *str, size_type num );
  basic_string &append( size_type num, char ch );
  basic_string &append( input_iterator start, input_iterator end );
//在字符串的末尾添加str,
//在字符串的末尾添加str的子串,子串以index索引开始，长度为len
//在字符串的末尾添加str中的num个字符,
//在字符串的末尾添加num个字符ch,
//在字符串的末尾添加以迭代器start和end表示的字符序列.


直接添加另一个完整的字符串:如str1.append(str2);
添加另一个字符串的某一段子串:如str1.append(str2, 11, 7);
添加几个相同的字符:如str1.append(5, ‘.’);注意,个数在前字符在后.上面的代码意思为在str1后面添加5个"."
    
     //========================================  
#include<iostream>  
using namespace std;  
//========================================  
int main()  
  
{  
    string str1="I like C++";  
    string str2=",I like the world.";  
    string str3="Hello";  
    string str4("Hi");  
    //====================================  
    str1.append(str2);  
    str3.append(str2, 11, 7);  
    str4.append(5, '.');  
    //====================================  
    cout<<str1<<endl;  
    cout<<str3<<endl;  
    cout<<str4<<endl;  
    system("pause");  
    return 0;     
}  
//========================================

```

## std::condition_variable

```rust
一、std::condition_variable

用在多线程中。

线程A：等待一个条件满足

线程B：专门在消息队列中扔消息，线程B触发了这个条件，A就满足条件了，可以继续执行

std::condition_variable my_cond;//生成一个条件对象

wait()是条件变量的成员函数，用来等一个东西，如果第二个参数lambda表达式返回值是false，那么wait将解锁第一个参数（互斥量），并堵塞到本行。
堵塞到什么时候呢？堵塞到其他某个线程调用notify_one（）成员函数为止。如果返回true，那么wait()直接返回。
如果没有第二个参数，就跟默认第二个参数返回false效果一样。

my_cond.notify_one();//尝试吧wait的线程唤醒，执行完这行，wait就被唤醒了
只能通知一个线程，如果两个线程干的不同的事情，都卡在wait，怎么唤醒多个线程？notify_all，这两个线程只有一个线程能获取到锁，另一个没拿到锁，就一直不断的去获得锁

当其他notify_one()将wait唤醒之后，wait不断尝试获取互斥量锁，如果获取不到，流程就卡在wait这里等着获取。如果获取到了，wait就获取到锁（就等于上锁）；
（1）如果wait有第二个参数（lambda）,就判断这个表达式，如果lambda为false，那么流程如上，又休眠，再等待唤醒；
（2）如果表达式为true，那么wait返回，流程走下来（此时互斥量锁还是锁着的），流程只要能走到这里来，这个互斥量锁一定是锁着的。
（3）如果没有第二个参数，wait就返回，流程走下来


加入A线程正在处理一个事物 ，需要一段时间，并没有卡在wait等你唤醒，那么B线程调用notify_one就没有效果了。
A线程notify_one之后，可能会接着lock，而另一个线程可能也在lock，两个线程谁先拿到锁不一定，所以竞争锁问题出现了。


[capture list] (parameter list) -> return type { function body }
其中除了“[ ]”（其中捕获列表可以为空）和“复合语句”（相当于具名函数定义的函数体），其它都是可选的。它的类型是单一的具有成员operator()的非联合的类类型，称为闭包类型（closure type）。
```

```C++
wait();
//功能：阻塞当前线程直到唤醒
//wait() 的第一个参数是一个unique_lock,
//第二个参数是true/false或没有第二个参数。第二个参数是用来判断是否满足条件，所以经常使用lambda表达式。第二个参数作用如下：
	wait()第二个参数：
    （1） 如果第二个参数为true，则wait()返回，流程走下来（此时本线程互斥量已经加锁）
    （2） 如果第二个参数为false，则wait()阻塞在这里，并解锁互斥量
    （3）如果没有第二个参数，wait()会阻塞到这里，并解锁互斥量（与false一样）
        
当wait()阻塞到本行时，其他线程可以用同一个条件变量notify_one()唤醒当前阻塞的线程。当此线程被唤醒时：
    wait()会尝试重新获取锁，如果没有获取到，则卡在这里继续尝试获取锁。
    如果获取到了锁：
    （1）判断wait()的第二个参数，如果为true，则返回，流程走下来
    （2）判断wait()的第二个参数，如果为false，则解锁互斥量，继续阻塞
    （3）没有第二个参数，流程走下来。
        
        
成员函数notify_one()/notify_all()唤醒线程
    std::condition_variable::notify_one()
    唤醒某个等待(wait)线程。如果当前没有等待线程，则该函数什么也不做，如果同时存在多个等待线程，则唤醒某个线程是不确定的。
    std::condition_variable::notify_all()
    唤醒所有的等待(wait)线程。如果当前没有等待线程，则该函数什么也不做。
```



## C++函数：std::async

```C++
std::async()是一个接受回调(函数或函数对象)作为参数的函数模板，并有可能异步执行它们.
template<class Fn, class... Args>
future<typename result_of<Fn(Args...)>::type> async(launch policy, Fn&& fn, Args&&...args);

std::async返回一个 std::future<T>，它存储由 std::async()执行的函数对象返回的值。
函数期望的参数可以作为函数指针参数后面的参数传递给std::async()。
    
std::async中的第一个参数是启动策略，它控制std::async的异步行为，我们可以用三种不同的启动策略来创建std::async
//·std::launch::async
保证异步行为，即传递函数将在单独的线程中执行
//·std::launch::deferred
当其他线程调用get()来访问共享状态时，将调用非异步行为
//·std::launch::async | std::launch::deferred
默认行为。有了这个启动策略，它可以异步运行或不运行，这取决于系统的负载，但我们无法控制它。

```

## C++函数：std::tie 详解

```C++
std::tie：创建左值引用的 tuple，或将 tuple 解包为独立对象
//返回值:含左值引用的 std::tuple 对象。
//注意:std::tie 可用于解包 std::pair ，因为 std::tuple 拥有从 pair 的转换赋值：

示例 

std::tie(iRet, tStockPosition.dTotalValueHKD, dModifyProfit) = ReCalStockValue(pendsettle, dSettleRate);
// 返回值：(状态码，成本，盈亏修正值)
std::tuple<int, double, double> ReCalStockValue(std::shared_ptr<TPendSettleData> pendsettle, double settleRate) {
    return std::make_tuple(1, 0, 0);
}


```

## pair

```C++
//开收盘的集合竞价时间区间
map<StockExchange, vector<pair<string, string>>> StockExchangeCallAuctionArea = {
	{SE_SSE, {{"09:15:00","09:30:00"}, {"15:00:00","15:01:00"}}},
	{SE_SZSE, {{"09:15:00","09:30:00"}, {"15:00:00","15:01:00"}}},
	{SE_CNB, {{"09:15:00","09:30:00"}, {"15:00:00","15:02:00"}}},
	{SE_CNI, {{"09:15:00","09:30:00"}, {"15:00:00","15:02:00"}}},
	{SE_HKEX, {{"09:00:00","09:30:00"}, {"16:00:00","16:10:00"}}},
	{SE_HKB, {{"09:00:00","09:30:00"}, {"16:00:00","16:10:00"}}},
	{SE_HKI, {{"09:00:00","09:30:00"}, {"16:00:00","16:10:00"}}},
	{SE_ASE, {{"09:30:01","09:30:00"}, {"16:00:00","16:01:00"}}},
	{SE_NYSE, {{"09:30:01","09:30:00"}, {"16:00:00","16:01:00"}}},
	{SE_NASDAQ, {{"09:30:01","09:30:00"}, {"16:00:00","16:01:00"}}},
	{SE_USB, {{"09:30:01","09:30:00"}, {"16:00:00","16:01:00"}}},
	{SE_USI, {{"09:30:01","09:30:00"}, {"16:00:00","16:01:00"}}},
};

pair将一对值(T1和T2)组合成一个值，
这一对值可以具有不同的数据类型（T1和T2），

两个值可以分别用pair的两个公有函数first和second访问。
```

## 多线程

```C++

```

## std::ios_base::unsetf

```C++
void unsetf( fmtflags flags );
flags	-	要反设置的格式化标志。它能为下列常量的组合：
 
常量	解释
dec	为整数 I/O 使用十进制底：见 std::dec
oct	为整数 I/O 使用八进制底：见 std::oct
hex	为整数 I/O 使用十六进制底：见 std::hex
basefield	dec|oct|hex 。适用于掩码运算
left	左校正（添加填充字符到右）：见 std::left
right	右校正（添加填充字符到左）：见 std::right
internal	内部校正（添加填充字符到内部选定点）：见 std::internal
adjustfield	left|right|internal 。适用于掩码运算
scientific	用科学记数法生成浮点类型，或若与 fixed 组合则用十六进制记法：见 std::scientific
fixed	用定点记法生成浮点类型，或若与 scientific 组合则用十六进制记法：见 std::fixed
floatfield	scientific|fixed 。适用于掩码运算
boolalpha	以字母数字格式插入并释出 bool 类型：见 std::boolalpha
showbase	生成为整数输出指示数字基底的前缀，货币 I/O 中要求现金指示器：见 std::showbase
showpoint	无条件为浮点数输出生成小数点字符：见 std::showpoint
showpos	为非负数值输出生成 + 字符，见 std::showpos
skipws	在具体输入操作前跳过前导空白符：见 std::skipws
unitbuf	在每次输出操作后冲入输出：见 std::unitbuf
uppercase	在具体输出的输出操作中以大写等价替换小写字符：见 std::uppercase
    
    
fmtflags setf( fmtflags flags );(1)	
fmtflags setf( fmtflags flags, fmtflags mask );(2)

flags, mask	-	新格式化设定。 mask 定义哪些标志可以改变， flags 定义要改变的标志中该设置那些（其他将被清除）。两个参数都能为下列常量的组合：
 
常量	解释
dec	为整数 I/O 使用十进制底：见 std::dec
oct	为整数 I/O 使用八进制底：见 std::oct
hex	为整数 I/O 使用十六进制底：见 std::hex
basefield	dec|oct|hex 。适用于掩码运算
left	左校正（添加填充字符到右）：见 std::left
right	右校正（添加填充字符到左）：见 std::right
internal	内部校正（添加填充字符到内部选定点）：见 std::internal
adjustfield	left|right|internal 。适用于掩码运算
scientific	用科学记数法生成浮点类型，或若与 fixed 组合则用十六进制记法：见 std::scientific
fixed	用定点记法生成浮点类型，或若与 scientific 组合则用十六进制记法：见 std::fixed
floatfield	scientific|fixed 。适用于掩码运算
boolalpha	以字母数字格式插入并释出 bool 类型：见 std::boolalpha
showbase	生成为整数输出指示数字基底的前缀，货币 I/O 中要求现金指示器：见 std::showbase
showpoint	无条件为浮点数输出生成小数点字符：见 std::showpoint
showpos	为非负数值输出生成 + 字符，见 std::showpos
skipws	在具体输入操作前跳过前导空白符：见 std::skipws
unitbuf	在每次输出操作后冲入输出：见 std::unitbuf
uppercase	在具体输出的输出操作中以大写等价替换小写字符：见 std::uppercase

返回值
调用函数前的格式化标志
```

## 容器迭代

```C++
for(auto &a: b)//循环体中修改a,b中对应的数据也会改变
    
for(auto a: b)//循环体重修改a,b中的数据不受影响
    
for(const auto &a: b)//不可修改，用于只读b中的数据
    
    
c++ 里面的map容器的迭代器first、second用法
例：
map<string, int> m_stlmap;
m_stlmap[“xiaomi”] = 88;

auto mpit = m_stlmap.begin();
first会得到Map中key的有效值，
second会得到Map中value的有效值。

所以
mpit ->first; // 得到是 string 值是 “xiaomi”
mpit ->second; //得到是 int 值是 88
————————————————
版权声明：本文为CSDN博主「漂过」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_33786136/article/details/106712042
```



## c++ 中map 的find 用法

```C++
用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器，程序说明
#include <map>
#include <string>
#include <iostream>
Using namespace std;
Int main()
{
       Map<int, string> mapStudent;
       mapStudent.insert(pair<int, string>(1, “student_one”));
       mapStudent.insert(pair<int, string>(2, “student_two”));
       mapStudent.insert(pair<int, string>(3, “student_three”));
       map<int, string>::iterator iter;
       iter = mapStudent.find(1);
if(iter != mapStudent.end())//找到
{
       Cout<<”Find, the value is ”<<iter->second<<endl;
}
Else
{
       Cout<<”Do not Find”<<endl;
}
}
```



# 数据库

## MYSQL

### order by和limit

```sql
利用order by进行排序，降序（从大到写）可以用desc，升序（从小到大）是默认的
order by [desc,asc]
    用于对记录进行 排序

    desc为降序
    asc为升序

    按照工资的从低到高顺序 显示所有的员工
    select *from emp order by salary;
    默认为升序

    修改为降序
    select *from emp order by salary desc;

    按照每个部门的平均工资 降序排序
    select dept,avg(salary) from emp group by dept order by avg(salary) desc;


limit  *******
    用于限制显示的条数
    limit [start,]count

    # 看看表里前三条数据
    select *from emp limit 3;

    # 看看表里的3-5条
    select * from emp limit 2,3;

    # 查看工资最高的那个人的信息
    select *from emp order by salary desc limit 1;

    limit 常用于 数据的分页展示  比如腾讯新闻 的上拉加载新的而一页
    select *from emp limit 0,10; 第一页     页数 减1  乘以条数 得到起始位置
    select *from emp limit 10,10; 第2页
    select *from emp limit 20,10; 第3页
    
    
select l_unit_id, l_stock_id, l_channel_id, l_begin_amount, en_begin_value_hkd 
from thisstockposition where l_unit_id = 200953 and l_stock_id = 9803 and l_channel_id = 4 ORDER BY l_date asc limit 1;

select * from thisstockposition where l_unit_id = 200953 and l_stock_id = 9803 and l_channel_id = 4  and l_begin_amount > 0 ORDER BY l_date desc;

select * from thisstockposition where l_unit_id = 200953 and l_stock_id = 9803 and l_channel_id = 4  and l_current_amount > 0 ORDER BY l_date desc;

SELECT
	* 
FROM
	thisstockposition 
WHERE
	l_unit_id = 200585 
	AND l_stock_id = 10783 
	AND l_channel_id = 9 
ORDER BY
	l_date DESC;
	
select * from thisstockposition WHERE l_unit_id = 200585 AND l_stock_id = 10783 AND l_channel_id = 9 and l_date = 20220129;
```



## Redis

```c++
Redis Hexists 命令用于查看哈希表的指定字段是否存在。
Redis Lrange 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。
```

## Cassandra

```C++
cassandra是一个来自Apache分布式数据库,具有高度可扩展性,可用与管理大量的结构化数据,提供了高可用性,没有单点故障.
    
Cassandra的主要特点就是它不是一个数据库，而是由一堆数据库节点共同构成的一个分布式网络服务，
对Cassandra 的一个写操作，会被复制到其他节点上去，对Cassandra的读操作，也会被路由到某个节点上面去读取。
```

### NoSQL数据库

```C++
NoSQL数据库(not Only SQL[不仅仅是SQL])是一种数据库,//它提供了一种机制来存储和检索数据,而不是关系数据库中使用的表格关系,这些数据库是无架构的,支持简单的复制,具有简单的API,最终一致,并且可以处理大量的数据
NoSQL数据库的主要目的在于:
	1、设计简单
	2、水平缩放
	3、更好的控制可用性
//与关系型数据库相比，NoSQL数据库使用不同的数据结构，它使NoSQL中的一些操作更快，给定NoSQL数据库的使用性取决与他必须解决的问题
        
关系数据库										NoSQL数据库
支持强大的查询语言。								支持非常简单的查询语言。
它具有固定的模式。								无固定模式。
遵循ACID（原子性，一致性，隔离性和持久性）。			只有“最终一致”。
支持事务。											不支持事务。
```

### Cassandra的特点

```C++
弹性可扩展性 - Cassandra是高度可扩展的; 它允许添加更多的硬件以适应更多的客户和更多的数据根据要求。

始终基于架构 - Cassandra没有单点故障，它可以连续用于不能承担故障的关键业务应用程序。

快速线性性能 - Cassandra是线性可扩展性的，即它为你增加集群中的节点数量增加你的吞吐量。因此，保持一个快速的响应时间。

灵活的数据存储 - Cassandra适应所有可能的数据格式，包括：结构化，半结构化和非结构化。它可以根据您的需要动态地适应变化的数据结构。

便捷的数据分发 - Cassandra通过在多个数据中心之间复制数据，可以灵活地在需要时分发数据。

事务支持 - Cassandra支持属性，如原子性，一致性，隔离和持久性（ACID）。

快速写入 - Cassandra被设计为在廉价的商品硬件上运行。 它执行快速写入，并可以存储数百TB的数据，而不牺牲读取效率。
```

### Cassandra的组件

```C++
节点 - 它是存储数据的地方。

数据中心 - 它是相关节点的集合。

集群 - 集群是包含一个或多个数据中心的组件。

提交日志 - 提交日志是Cassandra中的崩溃恢复机制。每个写操作都写入提交日志。

Mem-表 - mem-表是存储器驻留的数据结构。提交日志后，数据将被写入mem表。有时，对于单列族，将有多个mem表。

SSTable - 它是一个磁盘文件，当其内容达到阈值时，数据从mem表中刷新。

布隆过滤器 - 这些只是快速，非确定性的算法，用于测试元素是否是集合的成员。它是一种特殊的缓存。 每次查询后访问Bloom过滤器。
```



# linux

## vim

```C++
向上查找: Shift + 3 (#号)
向下查找: Shift + 8 (*号)         
跳到行尾: Shift + 4($)
跳到行首: Shift + 6(^)
```

![img](https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif)

```c
//动态查看日志
    tail -f name.log
        
        
1、安装中文支持包
locale　　# 查看当前系统语言环境
locale -a　　# 查看系统支持的所有语言
yum groupinstall "fonts"  # centos7
yum groupinstall "Chinese Support" # centos6 

2、修改当前系统支持中文
#以下是CentOS 7.x和CentOS 6.x的路径：
vim /etc/locale.conf　　 # centos7
vim /etc/sysconfig/i18n　　# centos6
#把其中的 LANG="en_US.UTF-8" 改为 LANG="zh_CN.UTF-8"，然后保存。
source /etc/locale.conf  # CentOS7 重新加载该文件使区域语言设置立即生效。
source /etc/sysconfig/i18n　# CentOS6 重新加载该文件使区域语言设置立即生效。
        
查看进程id     
ps -ef | grep 程序名        
这样可以动态实时的看到CPU和内存的占用率，然后按q键回到命令行
top -p 进程号
        
        
        
//处理目录的常用命令
接下来我们就来看几个常见的处理目录的命令吧：

ls（英文全拼：list files）: 列出目录及文件名
cd（英文全拼：change directory）：切换目录
pwd（英文全拼：print work directory）：显示目前的目录
mkdir（英文全拼：make directory）：创建一个新的目录
rmdir（英文全拼：remove directory）：删除一个空的目录
cp（英文全拼：copy file）: 复制文件或目录
rm（英文全拼：remove）: 删除文件或目录
mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称
    

//Linux 文件内容查看
Linux系统中使用以下命令来查看文件的内容：

cat  由第一行开始显示文件内容
tac  从最后一行开始显示，可以看出 tac 是 cat 的倒着写！
nl   显示的时候，顺道输出行号！
more 一页一页的显示文件内容
less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
head 只看头几行
tail 只看尾巴几行
    
    
    
//Linux 磁盘管理
Linux 磁盘管理好坏直接关系到整个系统的性能问题。
Linux 磁盘管理常用三个命令为 df、du 和 fdisk。
df（英文全称：disk full）：列出文件系统的整体磁盘使用量
du（英文全称：disk used）：检查磁盘空间使用量
fdisk：用于磁盘分区
    
    
搜索替换
/word	向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)
?word	向光标之上寻找一个字符串名称为 word 的字符串。
```

1.  
    ffi指的是 foreign function interface（我理解为外部函数接口）
2.  说白了就是rust调用c/c++和c/c++调用rust。不管是各类书籍和各类的教学文章里都已经写明了
3.  他们改怎样做，这里我们也就不再啰嗦了。但是在编译、构建方面，提到的内容比较少，大部分是
4.  使用rustc命令做编译链接(rustc -L /path/to/lib xxx.rs)。
5.  涉及到cargo配置的很少很少。
6.  

## 重定向标准输出

```C++
1、使用重定向运算符“>”和“>>”。

2、使用tee命令。

3、使用日志保存logsave命令。

参考：Linux下使用>和>>重定向运算符或tee命令将文本写入文件。

 

//1、使用重定向运算符“>”和“>>”将终端输出保存到文件中

将命令的输出从终端重定向到文件的最常见方法是使用“>”和“>>”运算符。

>：它将输出重定向到文件并覆盖文件的现有内容。

>>：它将输出附加到文件的末尾。

要创建/覆盖文件，请使用以下语法：

$ command > [filename]

例如，要将hostnamectl命令输出保存到文件“myfile.txt”，请运行：

$ hostnamectl > myfile.txt

要附加文件，请使用以下语法：

$ command >> [filename]

例如，要将uname命令输出附加到文件“myfile.txt”，请运行：

$ uname -a >> myfile.txt

现在，您可以使用cat命令从myfile.txt文件中查看这两个命令的输出：

$ cat myfile.txt
    
//2、使用tee命令将命令输出保存到文件

上述方法不会在终端上显示命令输出，但tee命令将结果同时写入标准输出（stdout）和一个或多个文件。

语法：

[command] | tee [options] [filename]

要使用tee命令使用命令的输出创建新文件或覆盖现有文件的内容，请运行：

$ free | tee myfile_tee.txt

将Linux系统命令输出重定向到文件的三种方法

要将命令输出附加到文件而不覆盖其现有内容，请运行：

$ date | tee -a myfile_tee.txt

Fri Jul 16 13:53:34 IST 2021

现在，您可以使用cat命令从“myfile_tee.txt”文件中查看这两个命令的输出：

$ cat myfile_tee.txt
    
3、使用logsave命令将命令输出重定向到文件

logsave命令的工作方式类似于tee命令，并添加命令执行的时间戳（日期和时间）。

它为每个命令输出添加两个时间戳：

1]、Start Time（First Time）：这是指命令执行的开始时间。

2]、End Time (Second Time)：这表示命令的完成时间。

请注意：logsave命令需要超级用户权限才能运行（例如root或sudo）。

语法：

logsave [filename] [command]

例如，要将lsblk命令输出保存到文件“myfile_logsave.txt”，请运行：

$ sudo logsave myfile_logsave.txt lsblk

将Linux系统命令输出重定向到文件的三种方法

要将 ip 命令的输出附加到现有文件“myfile_logsave.txt”，请运行：

$ sudo logsave -a myfile_logsave.txt ip a
    
    
//(3) 运行程序

命令	说明
./hello	ctrl + c 以中断程序
 	 
./hello &	ctrl + c 不能中断程序，因为程序在后台运行，只是日志打印到了前台
./hello >> hello.log &	重定向日志到 hello.log。可以使用 jobs 命令查看后台 hello 进程。 查看日志 tail -fn 5 hello.log
 	 
nohup ./hello	ctrl + c 程序中断；关闭终端窗口，程序不中断
nohup ./hello &	ctrl + c 不中断；关闭终端窗口，不中断
```



# Redis

```C++
tcp://user:pass@127.0.0.1:7000/1


1 . 安装

# 安装 redis 连接池
composer require easyswoole/redis-pool --ignore-platform-reqs
2 . 注册 redis 连接池

在 框架 启动事件类 EasySwooleEvent.php 中的 mainServerCreate() 方法中 注册redis连接池
try {
    $redisConfig = new \EasySwoole\Redis\Config\RedisConfig([
         "host"=>"127.0.0.1", // 设置 host
         "port"=>6379,// 设置 端口
         "auth"=>"",// 设置redis登陆密码
         "timeout"=>3, // 选择超时时间
         "reconnectTimes"=>3,// 配置重连时间
         "db"=>0, // 配置使用的数据库
    ]);
    $redisPoolConfig = \EasySwoole\RedisPool\Redis::getInstance()->register('redis',$redisConfig);
    $redisPoolConfig->setMinObjectNum(5); //最小连接 5
    $redisPoolConfig->setMaxObjectNum(20); // 最大连接数 20
    $redisPoolConfig->setGetObjectTimeout(3);
} catch (\Throwable $e) {
    var_dump($e->getMessage());
}
使用连接池

$redisPool = \EasySwoole\RedisPool\Redis::getInstance()->get('redis');
try {
    $redis = $redisPool->getObj(); // 获取 一个 redis 连接
    $redis->get("name");
    $redisPool->recycleObj($redis); // 归还连接
} catch (\Throwable $e) {
    var_dump($e->getMessage());
}
```

```C++
tcp://[[username:]password@]host[:port][/db]
unix://[[username:]password@]path-to-unix-domain-socket[/db]



// Single connection to the given host and port.//到给定主机和端口的单一连接。
Redis redis1("tcp://127.0.0.1:6666");

// Use default port, i.e. 6379.//使用默认端口，即6379。
Redis redis2("tcp://127.0.0.1");

// Connect to Redis with password, and default port.//使用密码和默认端口连接到Redis。
Redis redis3("tcp://pass@127.0.0.1");

// Connect to Redis and select the 2nd (db number starts from 0) database.//连接到Redis并选择第二个（数据库编号从0开始）数据库。
Redis redis4("tcp://127.0.0.1:6379/2");

// Set keep_alive option to true with query string.//使用查询字符串将keep_alive选项设置为true。
Redis redis5("tcp://127.0.0.1:6379/2?keep_alive=true");

// Set socket_timeout to 50 milliseconds, and connect_timeout to 1 second with query string.
//将套接字超时设置为50毫秒，并使用查询字符串将超时设置为1秒。
Redis redis6("tcp://127.0.0.1?socket_timeout=50ms&connect_timeout=1s");

// Connect to Unix Domain Socket.
//连接到Unix域套接字。
Redis redis7("unix://path/to/socket");

```

```c++
#include <sw/redis++/redis++.h>

using namespace sw::redis;

try {
    // Create an Redis object, which is movable but NOT copyable.
    //创建一个可移动但不可复制的Redis对象。
    auto redis = Redis("tcp://127.0.0.1:6379");

    // ***** STRING commands *****

    redis.set("key", "val");
    auto val = redis.get("key");    // val is of type OptionalString. See 'API Reference' section for details.
    //val的类型为OptionalString。有关详细信息，请参阅“API参考”部分。
    if (val) {
        // Dereference val to get the returned value of std::string type.
        //取消引用val以获取std:：string类型的返回值。
        std::cout << *val << std::endl;
    }   // else key doesn't exist.
    //否则密钥不存在

    // ***** LIST commands *****

    // std::vector<std::string> to Redis LIST.
    std::vector<std::string> vec = {"a", "b", "c"};
    redis.rpush("list", vec.begin(), vec.end());

    // std::initializer_list to Redis LIST.
    redis.rpush("list", {"a", "b", "c"});

    // Redis LIST to std::vector<std::string>.
    vec.clear();
    redis.lrange("list", 0, -1, std::back_inserter(vec));

    // ***** HASH commands *****

    redis.hset("hash", "field", "val");

    // Another way to do the same job.
    //做同样工作的另一种方法。
    redis.hset("hash", std::make_pair("field", "val"));

    // std::unordered_map<std::string, std::string> to Redis HASH.
    std::unordered_map<std::string, std::string> m = {
        {"field1", "val1"},
        {"field2", "val2"}
    };
    redis.hmset("hash", m.begin(), m.end());

    // Redis HASH to std::unordered_map<std::string, std::string>.
    m.clear();
    redis.hgetall("hash", std::inserter(m, m.begin()));

    // Get value only.
    //仅获取价值
    // NOTE: since field might NOT exist, so we need to parse it to OptionalString.
    //由于字段可能不存在，所以我们需要将其解析为OptionalString。
    std::vector<OptionalString> vals;
    redis.hmget("hash", {"field1", "field2"}, std::back_inserter(vals));

    // ***** SET commands *****

    redis.sadd("set", "m1");

    // std::unordered_set<std::string> to Redis SET.
    std::unordered_set<std::string> set = {"m2", "m3"};
    redis.sadd("set", set.begin(), set.end());

    // std::initializer_list to Redis SET.
    redis.sadd("set", {"m2", "m3"});

    // Redis SET to std::unordered_set<std::string>.
    set.clear();
    redis.smembers("set", std::inserter(set, set.begin()));

    if (redis.sismember("set", "m1")) {
        std::cout << "m1 exists" << std::endl;
    }   // else NOT exist.

    // ***** SORTED SET commands *****

    redis.zadd("sorted_set", "m1", 1.3);

    // std::unordered_map<std::string, double> to Redis SORTED SET.
    std::unordered_map<std::string, double> scores = {
        {"m2", 2.3},
        {"m3", 4.5}
    };
    redis.zadd("sorted_set", scores.begin(), scores.end());

    // Redis SORTED SET to std::vector<std::pair<std::string, double>>.
    // NOTE: The return results of zrangebyscore are ordered, if you save the results
    // in to `std::unordered_map<std::string, double>`, you'll lose the order.
    std::vector<std::pair<std::string, double>> zset_result;
    redis.zrangebyscore("sorted_set",
            UnboundedInterval<double>{},            // (-inf, +inf)
            std::back_inserter(zset_result));

    // Only get member names:
    // pass an inserter of std::vector<std::string> type as output parameter.
    std::vector<std::string> without_score;
    redis.zrangebyscore("sorted_set",
            BoundedInterval<double>(1.5, 3.4, BoundType::CLOSED),   // [1.5, 3.4]
            std::back_inserter(without_score));

    // Get both member names and scores:
    // pass an back_inserter of std::vector<std::pair<std::string, double>> as output parameter.
    std::vector<std::pair<std::string, double>> with_score;
    redis.zrangebyscore("sorted_set",
            BoundedInterval<double>(1.5, 3.4, BoundType::LEFT_OPEN),    // (1.5, 3.4]
            std::back_inserter(with_score));

    // ***** SCRIPTING commands *****

    // Script returns a single element.
    auto num = redis.eval<long long>("return 1", {}, {});

    // Script returns an array of elements.
    std::vector<long long> nums;
    redis.eval("return {ARGV[1], ARGV[2]}", {}, {"1", "2"}, std::back_inserter(nums));

    // mset with TTL
    auto mset_with_ttl_script = R"(
        local len = #KEYS
        if (len == 0 or len + 1 ~= #ARGV) then return 0 end
        local ttl = tonumber(ARGV[len + 1])
        if (not ttl or ttl <= 0) then return 0 end
        for i = 1, len do redis.call("SET", KEYS[i], ARGV[i], "EX", ttl) end
        return 1
    )";

    // Set multiple key-value pairs with TTL of 60 seconds.
    //设置多个键值对，TTL为60秒。
    auto keys = {"key1", "key2", "key3"};
    std::vector<std::string> args = {"val1", "val2", "val3", "60"};
    redis.eval<long long>(mset_with_ttl_script, keys.begin(), keys.end(), vals.begin(), vals.end());

    // ***** Pipeline *****

    // Create a pipeline.
    //创建一个管道。
    auto pipe = redis.pipeline();

    // Send mulitple commands and get all replies.
    //发送多个命令并获取所有回复。
    auto pipe_replies = pipe.set("key", "value")
                            .get("key")
                            .rename("key", "new-key")
                            .rpush("list", {"a", "b", "c"})
                            .lrange("list", 0, -1)
                            .exec();

    // Parse reply with reply type and index.
    //使用回复类型和索引分析回复。
    auto set_cmd_result = pipe_replies.get<bool>(0);

    auto get_cmd_result = pipe_replies.get<OptionalString>(1);

    // rename command result
    //重命名命令结果
    pipe_replies.get<void>(2);

    auto rpush_cmd_result = pipe_replies.get<long long>(3);

    std::vector<std::string> lrange_cmd_result;
    pipe_replies.get(4, back_inserter(lrange_cmd_result));

    // ***** Transaction *****

    // Create a transaction.
    //创建一个事务。
    auto tx = redis.transaction();

    // Run multiple commands in a transaction, and get all replies.
    //在事务中运行多个命令，并获取所有回复。
    auto tx_replies = tx.incr("num0")
                        .incr("num1")
                        .mget({"num0", "num1"})
                        .exec();

    // Parse reply with reply type and index.
    //使用回复类型和索引分析回复。
    auto incr_result0 = tx_replies.get<long long>(0);

    auto incr_result1 = tx_replies.get<long long>(1);

    std::vector<OptionalString> mget_cmd_result;
    tx_replies.get(2, back_inserter(mget_cmd_result));

    // ***** Generic Command Interface *****通用命令接口

    // There's no *Redis::client_getname* interface.
    // But you can use *Redis::command* to get the client name.
    val = redis.command<OptionalString>("client", "getname");
    if (val) {
        std::cout << *val << std::endl;
    }

    // Same as above.
    auto getname_cmd_str = {"client", "getname"};
    val = redis.command<OptionalString>(getname_cmd_str.begin(), getname_cmd_str.end());

    // There's no *Redis::sort* interface.
    // But you can use *Redis::command* to send sort the list.
    std::vector<std::string> sorted_list;
    redis.command("sort", "list", "ALPHA", std::back_inserter(sorted_list));

    // Another *Redis::command* to do the same work.
    auto sort_cmd_str = {"sort", "list", "ALPHA"};
    redis.command(sort_cmd_str.begin(), sort_cmd_str.end(), std::back_inserter(sorted_list));

    // ***** Redis Cluster *****

    // Create a RedisCluster object, which is movable but NOT copyable.
    auto redis_cluster = RedisCluster("tcp://127.0.0.1:7000");

    // RedisCluster has similar interfaces as Redis.
    redis_cluster.set("key", "value");
    val = redis_cluster.get("key");
    if (val) {
        std::cout << *val << std::endl;
    }   // else key doesn't exist.

    // Keys with hash-tag.
    redis_cluster.set("key{tag}1", "val1");
    redis_cluster.set("key{tag}2", "val2");
    redis_cluster.set("key{tag}3", "val3");

    std::vector<OptionalString> hash_tag_res;
    redis_cluster.mget({"key{tag}1", "key{tag}2", "key{tag}3"},
            std::back_inserter(hash_tag_res));

} catch (const Error &e) {
    // Error handling.
}





ConnectionOptions connection_options;
connection_options.host = "127.0.0.1";  // Required.
connection_options.port = 6666; // Optional. The default port is 6379.
connection_options.password = "auth";   // Optional. No password by default.
connection_options.db = 1;  // Optional. Use the 0th database by default.

// Optional. Timeout before we successfully send request to or receive response from redis.
// By default, the timeout is 0ms, i.e. never timeout and block until we send or receive successfuly.
// NOTE: if any command is timed out, we throw a TimeoutError exception.
//可选择的在我们成功向redis发送请求或从redis接收响应之前超时。
//默认情况下，超时为0ms，即在我们成功发送或接收之前从不超时和阻塞注意：
//如果任何命令超时，我们将抛出TimeoutError异常。
connection_options.socket_timeout = std::chrono::milliseconds(200);

// Connect to Redis server with a single connection.
//使用单个连接连接到Redis服务器。
Redis redis1(connection_options);

ConnectionPoolOptions pool_options;
pool_options.size = 3;  // Pool size, i.e. max number of connections.

// Optional. Max time to wait for a connection. 0ms by default, which means wait forever.
// Say, the pool size is 3, while 4 threds try to fetch the connection, one of them will be blocked.
//可选择的等待连接的最长时间。默认情况下为0毫秒，这意味着永远等待。例如，池大小为3，而4次尝试获取连接时，其中一次将被阻止。
pool_options.wait_timeout = std::chrono::milliseconds(100);

// Optional. Max lifetime of a connection. 0ms by default, which means never expire the connection.
// If the connection has been created for a long time, i.e. more than `connection_lifetime`,
// it will be expired and reconnected.
//可选择的连接的最大生存期。默认情况下为0毫秒，这意味着连接永远不会过期。如果连接已创建很长时间，即超过“连接生命周期”，它将过期并重新连接。
pool_options.connection_lifetime = std::chrono::minutes(10);

// Connect to Redis server with a connection pool.
//使用连接池连接到Redis服务器。
Redis redis2(connection_options, pool_options);








// Set a master node's host & port.
ConnectionOptions connection_options;
connection_options.host = "127.0.0.1";  // Required.
connection_options.port = 7000; // Optional. The default port is 6379.
connection_options.password = "auth"; // Optional. No password by default.

// Automatically get other nodes' info,
// and connect to every master node with a single connection.
RedisCluster cluster1(connection_options);

ConnectionPoolOptions pool_options;
pool_options.size = 3;

// For each master node, maintains a connection pool of size 3.
//对于每个主节点，维护一个大小为3的连接池。
RedisCluster cluster2(connection_options, pool_options);





#include <sw/redis++/redis++.h>

using namespace sw::redis;

auto redis_cluster = RedisCluster("tcp://127.0.0.1:7000");

redis_cluster.set("key", "value");
auto val = redis_cluster.get("key");
if (val) {
    std::cout << *val << std::endl;
}

// With hash-tag.
redis_cluster.set("key{tag}1", "val1");
redis_cluster.set("key{tag}2", "val2");
redis_cluster.set("key{tag}3", "val3");
std::vector<OptionalString> hash_tag_res;
redis_cluster.mget({"key{tag}1", "key{tag}2", "key{tag}3"},
        std::back_inserter(hash_tag_res));

redis_cluster.lpush("list", {"1", "2", "3"});
std::vector<std::string> list;
redis_cluster.lrange("list", 0, -1, std::back_inserter(list));

// Pipeline.
auto pipe = redis_cluster.pipeline("counter");
auto replies = pipe.incr("{counter}:1").incr("{counter}:2").exec();

// Transaction.
auto tx = redis_cluster.transaction("key");
replies = tx.incr("key").get("key").exec();

// Create a Redis object with hash-tag.
// It connects to the Redis instance that holds the given key, i.e. hash-tag.
auto r = redis_cluster.redis("hash-tag");

// And send command without key parameter to the server.
r.command("client", "setname", "connection-name");





```

```C++
#include <unistd.h>
#include <chrono>
#include <tuple>
#include <iostream>
#include <vector>
#include <map>
#include <unordered_set>
#include <sw/redis++/redis++.h>
#include <sw/redis++/sentinel.h>
#include <sw/redis++/connection.h>
#include <sw/redis++/connection_pool.h>
//using namespace std;
using namespace sw::redis;
using namespace std::chrono;
int main()
{
    ConnectionOptions connection_options;
    connection_options.host = "192.168.11.124";  // Required.//必修的。
    connection_options.port = 7001; // Optional. The default port is 6379.//可选择的默认端口是6379。
    //connection_options.password = "auth";   // Optional. No password by default.//可选择的默认情况下没有密码。
    connection_options.db = 0;  // Optional. Use the 0th database by default.//可选择的默认情况下使用第0个数据库。
 
    ConnectionPoolOptions pool_options;
    pool_options.size = 5;  // Pool size, i.e. max number of connections.池大小，即最大连接数。
    pool_options.wait_timeout = std::chrono::milliseconds(100);
 
 
    RedisCluster* redisofDB1 = NULL;
    try{
        redisofDB1 = new RedisCluster(connection_options, pool_options);
 
    }catch (const ReplyError &err) {
        printf("RedisHandler-- ReplyError：%s \n",err.what());
        return false ;
    }catch (const TimeoutError &err) {
        printf("RedisHandler-- TimeoutError%s \n",err.what());
        return false ;
    }catch (const ClosedError &err) {
        printf("RedisHandler-- ClosedError%s \n",err.what());
        return false ;
    }catch (const IoError &err) {
        printf("RedisHandler-- IoError%s \n",err.what());
        return false ;
    }catch (const Error &err) {
        printf("RedisHandler-- other%s \n",err.what());
        return false ;
    }
 
    // 连接成功- 下面开始干活儿。
    printf("-----连接成功，下面开始干活儿-----\n");
#if 1
    //1.先测试一个gethall 用hscan代替得吧
    auto cursor = 0LL;
    auto pattern = "*";
    auto count = 5;
    //std::unordered_set<std::string> keys;
    std::map<std::string, std::string> hashs;
    while (true) {
        cursor = redisofDB1->hscan("farm:status:NJTEST0000000005_20200702132812",cursor, pattern, count, std::inserter(hashs, hashs.begin()));
 
        if (cursor == 0) {
            break;
        }
    }
    if(hashs.size() < 1)
    {
        printf("we get nothing !\n");
    }
    std::cout << "the hashs.size = " <<  hashs.size() << std::endl;
    for(auto it1 = hashs.begin() ;it1 != hashs.end(); it1++)
    {
        std::cout <<"key:"  <<it1->first <<  "Value:"<<it1->second  <<std::endl;
    }
#endif
#if 0
    // 2.测试hsetnx 
    std::cout << "------------------------测试hsetnx---------------------------" << std::endl;
    std::string strValue = "SUBMIT$2$TES21129BH2000001$UPDATE$TIME:20200818163607,TYPE:3,VALUE:MjIzLjIyMy4xODcuMzUsMTA1MCxmdGFkbWluLGZ0YWRtaW44MTY0NSxINENfVjEuMy4zN18yMDIwMDgxN19hNDdhLmJpbiww,MODEL:2";
    //std::string strfeild = "1597739777";
    bool vBol = redisofDB1->hsetnx("farm:command:TES21129BH2000001", std::to_string(1597739778), strValue);
    
    std::cout << "hsetnx wanbi : " << vBol << std::endl;
 
    //3.测试hdel 
    bool vBol2 = redisofDB1->hdel("farm:command:TES21129BH2000001", strfeild);
    
    std::cout << "hdel wanbi : " << vBol2 << std::endl;
 
    //4.测试del
    bool vBol3 = redisofDB1->del("farm:command:NJTEST0000000009");
    
    std::cout << "del wanbi : " << vBol3 << std::endl;
 
    //5.hlen 
    long long llen = redisofDB1->hlen("farm:status:TST1010191210110_20200701114501");
    std::cout<< "the len is :" << llen << std::endl;
 
    //6.测试hset
    bool bbb = redisofDB1->hset("farm:clientnum","WUZ11010BC100009","009");
    std::cout << "hset finished is :" << bbb << std::endl;
 
 
    //7.测试expire
    redisofDB1->expire("farm:status:NJTEST0000000005_20200624135512",60);
#endif
 
    return 0;
}





//哨兵模式的。
#include <unistd.h>
#include <chrono>
#include <tuple>
#include <iostream>
#include <vector>
#include <map>
#include <sw/redis++/redis++.h>
#include <sw/redis++/sentinel.h>
#include <sw/redis++/connection.h>
#include <sw/redis++/connection_pool.h>
//using namespace std;
using namespace sw::redis;
int main()
{
	SentinelOptions sentinel_opts;
    // sentinel_opts.nodes = {{"127.0.0.1", 9000},
    //                     {"127.0.0.1", 9001},
    //                     {"127.0.0.1", 9002}};   // Required. List of Redis Sentinel nodes.必修的。Redis Sentinel节点列表。
    sentinel_opts.nodes = {{"192.168.127.134", 26379}};// Required. List of Redis Sentinel nodes.
    // Optional. Timeout before we successfully connect to Redis Sentinel.可选择的在我们成功连接到Redis Sentinel之前超时。
    // By default, the timeout is 100ms.默认情况下，超时为100ms。
    sentinel_opts.connect_timeout = std::chrono::milliseconds(200);
 
    // Optional. Timeout before we successfully send request to or receive response from Redis Sentinel.
    //可选择的在我们成功向Redis Sentinel发送请求或从Redis Sentinel接收响应之前超时。
    // By default, the timeout is 100ms.
    sentinel_opts.socket_timeout = std::chrono::milliseconds(200);
 
    auto sentinel = std::make_shared<Sentinel>(sentinel_opts);
 
 
    ConnectionOptions connection_opts;
    //connection_opts.password = "auth";  // Optional. No password by default.//默认情况下没有密码
    connection_opts.db = 1; 
    connection_opts.connect_timeout = std::chrono::milliseconds(100);   // Required.
    connection_opts.socket_timeout = std::chrono::milliseconds(100);    // Required.
 
    ConnectionPoolOptions pool_opts;
    pool_opts.size = 3; // Optional. The default size is 1.
 
    auto redis = Redis(sentinel, "mymaster", Role::MASTER, connection_opts, pool_opts);
    Redis* p = &redis;
    std::map<std::string, std::string> hash;
    p->hgetall("PLATINFO",std::inserter(hash, hash.end()));
 
    for(auto it = hash.begin() ;it != hash.end(); it++)
    {
        std::cout <<"Plat ID："  <<it->first <<std::endl;
        std::cout <<  "Plat UserName & Password"<<it->second <<std::endl;
    }
 
    ConnectionOptions connection_opts2;
    //connection_opts.password = "auth";  // Optional. No password by default.
    connection_opts2.db = 2; 
    connection_opts2.connect_timeout = std::chrono::milliseconds(100);   // Required.
    connection_opts2.socket_timeout = std::chrono::milliseconds(100);    // Required.
 
    auto redisDB2 = Redis(sentinel, "mymaster", Role::MASTER, connection_opts2, pool_opts);
    Redis*pp  = &redisDB2;
    std::map<std::string, std::string> hashTerm;
    pp->hgetall("TERMINAL:LIST:test123456789012",std::inserter(hashTerm, hashTerm.end()));
    
    
    for(auto it1 = hashTerm.begin() ;it1 != hashTerm.end(); it1++)
    {
        std::cout <<"Plat ID："  <<it1->first <<std::endl;
        std::cout <<  "Plat UserName & Password"<<it1->second <<std::endl;
    }
 
    // 是否存在
    bool bb = p->hexists("PLATINFO","test123456789012");
    std::cout << "PLATINFO 里 存在 test123456789012:" << bb << std::endl; 
 
 
    // hget - 注意这里，OptionalString 是大部分查询命令的返回值类型，要想转为string 需要加*
    OptionalString strValue = p->hget("PLATINFO","test1234567890123");
 
    std::cout<< " test123456789012  的 details :" << *strValue << std::endl;
    std::string straa = *strValue;
    if(straa.empty())
        {
           std::cout << "we gete nothing " << std::endl ;
        }
    std::cout<< " ---- test123456789012  的 details :" << straa << std::endl;
 
    // 测试hkeys
    std::vector<std::string> vPaltIDs;
    p->hkeys("PLATINFO",std::inserter(vPaltIDs, vPaltIDs.end()));
 
    for(auto vIter = vPaltIDs.begin();vIter != vPaltIDs.end(); vIter ++)
    {
        std::cout << *vIter << std::endl;
    }
	return 0;
}
 
 
 
 
//g++ -std=c++11 -I/usr/local/include -L/usr/local/lib -Wl,-rpath=../libc++ -o app testRedisSentinel.cpp -lredis++ -lhiredis -pthread
//




//连接单机模式的
#include <unistd.h>
#include <chrono>
#include <tuple>
#include <iostream>
#include <vector>
#include <map>
#include <unordered_set>
#include <sw/redis++/redis++.h>
#include <sw/redis++/sentinel.h>
#include <sw/redis++/connection.h>
#include <sw/redis++/connection_pool.h>
//using namespace std;
using namespace sw::redis;
using namespace std::chrono;
int main()
{
    ConnectionOptions connection_options;
    connection_options.host = "192.168.11.85";  // Required.
    connection_options.port = 16379; // Optional. The default port is 6379.
    //connection_options.password = "auth";   // Optional. No password by default.
    connection_options.db = 5;  // Optional. Use the 0th database by default.
 
    ConnectionPoolOptions pool_options;
    pool_options.size = 3;  // Pool size, i.e. max number of connections.
    pool_options.wait_timeout = std::chrono::milliseconds(100);
 
    ConnectionOptions connection_options2;
    connection_options2.host = "192.168.11.85"; 
    connection_options2.port = 16379;
    connection_options2.db = 7;
 
    ConnectionPoolOptions pool_options7;
    pool_options7.size = 3; 
    pool_options7.wait_timeout = std::chrono::milliseconds(100);
 
    Redis * redisofDB1 = NULL;
    Redis * redisofDB7 = NULL;
    // 开始连接
    try{
        redisofDB1 = new Redis(connection_options, pool_options);
    
        redisofDB7 = new Redis(connection_options2, pool_options7);
    }catch (const ReplyError &err) {
        printf("RedisHandler-- ReplyError：%s \n",err.what());
        return false ;
    }catch (const TimeoutError &err) {
        printf("RedisHandler-- TimeoutError%s \n",err.what());
        return false ;
    }catch (const ClosedError &err) {
        printf("RedisHandler-- ClosedError%s \n",err.what());
        return false ;
    }catch (const IoError &err) {
        printf("RedisHandler-- IoError%s \n",err.what());
        return false ;
    }catch (const Error &err) {
        printf("RedisHandler-- other%s \n",err.what());
        return false ;
    }
 
    /*
    std::map<std::string, std::string> hashTerm;
    redisofDB7->hgetall("FORWARD.PLAT.DETAIL",std::inserter(hashTerm, hashTerm.end()));
    
    
    for(auto it1 = hashTerm.begin() ;it1 != hashTerm.end(); it1++)
    {
        std::cout <<"Plat ID："  <<it1->first <<std::endl;
        std::cout <<  "Plat UserName & Password"<<it1->second <<std::endl;
    }
    */
 
    // 开始干活
    auto cursor = 0LL;
    auto pattern = "*";
    auto count = 5;
    //std::unordered_set<std::string> keys;
    std::map<std::string, std::string> hashs;
    while (true) {
        cursor = redisofDB7->hscan("FORWARD.PLAT.DETAIL",cursor, pattern, count, std::inserter(hashs, hashs.begin()));
 
        if (cursor == 0) {
            break;
        }
    }
    if(hashs.size() < 1)
    {
        printf("we get nothing !\n");
    }
    for(auto it1 = hashs.begin() ;it1 != hashs.end(); it1++)
    {
        std::cout <<"Plat ID："  <<it1->first <<std::endl;
        std::cout <<  "Plat UserName & Password"<<it1->second <<std::endl;
    }
 
    OptionalString strValue = redisofDB1->hget("XNY.CARINFO","CRC01211711100232");
    std::cout<< " CRC01211711100232  的 vin :" << *strValue << std::endl;
    std::string straa = *strValue;
    if(straa.empty())
    {
           std::cout << "we gete nothing " << std::endl ;
    }
    std::cout<< " ---- CRC01211711100232  的 details :" << straa << std::endl;
 
    std::cout<< " ---- 下面试试hincrby ---- " << std::endl;
 
 
 
    auto cursor2 = 0LL;
    auto pattern2 ="*";
    auto count2 = 20;
    std::map<std::string, std::string> vv;
    std::vector<std::string> vlist;
    while (true) {
        cursor2 = redisofDB7->hscan("FORWARD.LIST.002",cursor2, pattern2, count2, std::inserter(vv, vv.begin()));
 
        if (cursor2 == 0) {
            break;
        }
    }
 
    for(auto it1 = vv.begin() ;it1 != vv.end(); it1++)
    {
        vlist.push_back(it1->first);
    }
 
    for(auto uu = vlist.begin(); uu !=vlist.end(); uu ++ )
    {
        std::cout << *uu << std::endl;
    }
 
    return 0;
}
```

```C++
/// @brief Get the string value stored at key.//获取存储在键处的字符串值。
    ///
    /// Example:
    /// @code{.cpp}
    /// auto val = redis.get("key");
    /// if (val)
    ///     std::cout << *val << std::endl;
    /// else
    ///     std::cout << "key not exist" << std::endl;
    /// @endcode
    /// @param key Key.
    /// @return The value stored at key.
    /// @note If key does not exist, `get` returns `OptionalString{}` (`std::nullopt`).
    /// @see https://redis.io/commands/get
    OptionalString get(const StringView &key);

/// @brief Get the substring of the string stored at key.
    /// @param key Key.
    /// @param start Start index (inclusive) of the range. 0 means the beginning of the string.
    /// @param end End index (inclusive) of the range. -1 means the end of the string.
    /// @return The substring in range [start, end]. If key does not exist, return an empty string.
    /// @see https://redis.io/commands/getrange
    std::string getrange(const StringView &key, long long start, long long end);
```

```C++
Redis如果它收到错误回复或发生不良事件，例如，未能创建与服务器的连接，或者与服务器的连接断开，则会引发异常。派生自类的所有异常。有关详细信息，请参阅errors.h。Error

Error：一般错误。它派生自 ，也是其他异常的基类。std::exception
IoError：连接时出现一些 IO 错误。
TimeoutError：读取或写入操作超时。它是 的派生类。IoError
ClosedError：Redis 服务器已关闭连接。
ProtoError：命令或回复无效，我们无法使用 Redis 协议处理它。
OomError：hiredis库出现内存不足错误。
ReplyError：Redis 服务器返回了一个错误回复，例如，我们尝试调用 Redis 哈希。redis::lrange
WatchError：监视的键已被修改。有关详细信息，请参阅"监视"部分。
    
    
try {
    redis.set("key", "value");
    auto val = redis.get("key");
    int value = atoi(val.value().c_str());

    // Wrong type error
    redis.lpush("key", {"a", "b", "c"});
} catch (const ReplyError &err) {
    // WRONGTYPE Operation against a key holding the wrong kind of value
    cout << err.what() << endl;
} catch (const TimeoutError &err) {
    // reading or writing timeout
} catch (const ClosedError &err) {
    // the connection has been closed.
} catch (const IoError &err) {
    // there's an IO error on the connection.
} catch (const Error &err) {
   // other errors
}


// RedisCluster* redisofDB1 = NULL;
    // try{
    //     redisofDB1 = new RedisCluster(connection_options, pool_options);
 
    // }catch (const ReplyError &err) {
    //     printf("RedisHandler-- ReplyError：%s \n",err.what());
    //     return false ;
    // }catch (const TimeoutError &err) {
    //     printf("RedisHandler-- TimeoutError%s \n",err.what());
    //     return false ;
    // }catch (const ClosedError &err) {
    //     printf("RedisHandler-- ClosedError%s \n",err.what());
    //     return false ;
    // }catch (const IoError &err) {
    //     printf("RedisHandler-- IoError%s \n",err.what());
    //     return false ;
    // }catch (const Error &err) {
    //     printf("RedisHandler-- other%s \n",err.what());
    //     return false ;
    // }



redis 127.0.0.1:6379> SET db_number 0 # 默认使用...
2.OK
3.redis 127.0.0.1:6379> SELECT 1 # 使用 1 号数据库
4.OK
```



# grpc

## ubuntu系统Protobuf指定版本安装，以及报错解决方法

-   [ubuntu系统](https://www.it610.com/search/ubuntu系统/1.htm)



### ubuntu安装指定版本protobuf，无configure,makefile文件报错

-   -   1.查看protobuf版本
    -   2.安装指定版本protobuf
    -   3.报错无configure和makefile文件等等，比如安装protobuf3.0版本
    -   4.检查protobuf版本



## 1.查看protobuf版本

```javascript
protoc --version
```

## 2.安装指定版本protobuf

**前提：** 确保一下几个库都有安装

```javascript
sudo apt-get install autoconf automake libtool curl make g++ unzip
sudo yum install autoconf automake libtool curl make g++ unzip
```

**在此以安装protobuf3.6版本为例**

```javascript
git clone -b v3.6.0 https://github.com/protocolbuffers/protobuf.git
//安装哪个版本，v后面直接修改即可
cd protobuf
git submodule update --init --recursive
// 该命令表示克隆protobuf的子模块，主要是gtest
//没有反应，没问题继续进行
```

**编译protobuf源码，并进行安装**

```javascript
// 进入到克隆的protobuf目录
cd protobuf
./autogen.sh
./configure　--help//查看默认安装路径如下图所示，路径显示为/usr/local,则可以采用默认安装
./configure
make
// 如果没有克隆子模块，make check会失败但是可以继续make install,但是使用某些功能时可能会出错
make check
sudo make install
sudo ldconfig
// 输出protobuf版本信息则表示安装成功
protoc --version
```

[![在这里插入图片描述](https://img.it610.com/image/info8/847727abab9c456389ac9d1f69d47261.jpg)](https://img.it610.com/image/info8/847727abab9c456389ac9d1f69d47261.jpg)

## 3.报错无configure和makefile文件等等，比如安装protobuf3.0版本

**生成configure和makefile文件**

```javascript
cd protobuf
aclocal
autoconf
autoheader
automake --add-missing
./configure　--help//查看默认安装路径，若路径显示为/usr/local,则可以采用默认安装
./configure
make
sudo make install
```

**./configure一定要查看路径，因为ros自带protobuf2路径是在/usr/include下，如果不加路径的话，则会默认安装到/usr/include下，那个google文件就是了。这个结果则会导致protobuf2和protobuf3冲突，在编译cartographer文件的时候报错！！！**
**若路径显示为/usr,则需要改变默认路径**

```javascript
./configure　--prefix=/usr/local
```

继续上述步骤,make ,sudo make install

**若有报错出现configure.ac:\*: error: required file ‘autoconf/ltmain.sh’ not found**
安装libtools

```javascript
sudo apt install libtool
```

执行

```javascript
libtoolize --automake --copy --debug --force
```

**若有报错出现config.status: error: cannot find input file: `Makefile.in’**

```javascript
aclocal
libtoolize –automake 
automake --add-missing
./configure
make
sudo make install
```

## 4.检查protobuf版本

```javascript
protoc --version
```

**参考链接**
参考链接：自动生成configure和makefile
参考链接：Ubuntu18.04同时安装两个版本的protobuf



# vscode

```
格式化代码

这个快捷键可以帮助我们对代码进行缩进。
在 Windows 上：Shift + Alt + F

跳转到特定行
在 Windows 上：Ctrl + g
```

# redis和mysql的区别总结

```C++
一、.redis和mysql的区别总结

（1）类型上

        从类型上来说，mysql是关系型数据库，redis是缓存数据库

（2）作用上

       mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢

       redis用于存储使用较为频繁的数据到缓存中，读取速度快

（3）需求上

       mysql和redis因为需求的不同，一般都是配合使用。
    
二、详细说明

1.mysql和redis的数据库类型

mysql是关系型数据库，主要用于存放持久化数据，将数据存储在硬盘中，读取速度较慢。

redis是NOSQL，即非关系型数据库，也是缓存数据库，即将数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是保存时间有限

2.mysql的运行机制

mysql作为持久化存储的关系型数据库，相对薄弱的地方在于每次请求访问数据库时，都存在着I/O操作，如果反复频繁的访问数据库。第一：会在反复链接数据库上花费大量时间，从而导致运行效率过慢；第二：反复的访问数据库也会导致数据库的负载过高，那么此时缓存的概念就衍生了出来。

3.缓存

缓存就是数据交换的缓冲区（cache），当浏览器执行请求时，首先会对在缓存中进行查找，如果存在，就获取；否则就访问数据库。

缓存的好处就是读取速度快

4.redis数据库

redis数据库就是一款缓存数据库，用于存储使用频繁的数据，这样减少访问数据库的次数，提高运行效率。
```

# git

```C++
git init	//初始化仓库,生成.git目录
git init name	//指定目录作为仓库,在name下生成.git目录
    
git add		 //当前文件中的文件需要纳入版本控制中,使用该命令
git add *.c
git add README
git commit -m '初始化项目版本'
    
git stash//贮藏
    
在 Linux 系统中，commit 信息使用单引号 '，Windows 系统，commit 信息使用双引号 "。
所以在 git bash 中 git commit -m '提交说明' 这样是可以的，在 Windows 命令行中就要使用双引号 git commit -m "提交说明"。
    
//如果我们需要克隆到指定的目录，可以使用以下命令格式：
git clone <repo> <directory>
repo:Git //仓库。
directory://本地目录。
    
git add	//添加文件到仓库
git status	//查看仓库当前的状态，显示有变更的文件。
git diff	//比较文件的不同，即暂存区和工作区的差异。
git commit	//提交暂存区到本地仓库。
git reset	//回退版本。
git rm	//删除工作区文件。
git mv	//移动或重命名工作区文件。
    

git remote	//远程仓库操作
git fetch	//从远程获取代码库
git pull	//下载远程代码并合并
git push	//上传远程代码并合并
    
Git 分支管理   
//切换分支命令:
git checkout (branchname)
//列出分支基本命令：
git branch
//删除分支命令：
git branch -d (branchname)
//分支合并  
git merge
    
git log 		//- 查看历史提交记录。
git blame <file> //- 以列表形式查看指定文件的历史修改记录。
    
    
首先一定要进入工程目录下

sourcetree上重置推送（取消提交的推送），找到项目根目录如/Users/wang.er/Desktop/iosProject下执行命令，(Mac右侧->终端)执行命令：

git reset --soft HEAD^
直接执行这个命令之前提交到错误分支的代码直接取消提交了，非常的快

进入sourcetree上刷新查看当前已提交代码已经被回退，不在推送（）中
    
start a working area (see also: git help tutorial)//建立一个工作区
   clone             Clone a repository into a new directory//将存储库克隆到新目录中
   init              Create an empty Git repository or reinitialize an existing one//创建一个空的Git存储库或重新初始化现有的Git存储库

work on the current change (see also: git help everyday)//致力于当前的变化
   add               Add file contents to the index//将文件内容添加到索引中
   mv                Move or rename a file, a directory, or a symlink//移动或重命名文件、目录或符号链接
   restore           Restore working tree files//恢复工作树文件
   rm                Remove files from the working tree and from the index//从工作树和索引中删除文件
   sparse-checkout   Initialize and modify the sparse-checkout//初始化并修改稀疏签出

examine the history and state (see also: git help revisions)
   bisect            Use binary search to find the commit that introduced a bug//使用二进制搜索查找引入错误的提交
   diff              Show changes between commits, commit and working tree, etc//显示提交、提交和工作树等之间的更改
   grep              Print lines matching a pattern//打印与图案匹配的线条
   log               Show commit logs//显示提交日志
   show              Show various types of objects//显示各种类型的对象
   status            Show the working tree status//显示工作树状态

grow, mark and tweak your common history
   branch            List, create, or delete branches//列出、创建或删除分支
   commit            Record changes to the repository//记录对存储库的更改
   merge             Join two or more development histories together//将两个或多个开发历史结合在一起
   rebase            Reapply commits on top of another base tip//在另一个基本提示上重新应用提交
   reset             Reset current HEAD to the specified state//将当前磁头重置为指定状态
   switch            Switch branches
   tag               Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch             Download objects and refs from another repository
   pull              Fetch from and integrate with another repository or a local branch//从另一个存储库或本地分支获取并与之集成
   push              Update remote refs along with associated objects//更新远程参照以及关联的对象

'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help <command>' or 'git help <concept>'
to read about a specific subcommand or concept.
See 'git help git' for an overview of the system.
```

## 创建新的仓库导入代码

```rust
//步骤

//...或在命令行上创建新的存储库
echo "# rust-" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/Derrick-L98/rust.git
https://github.com/Derrick-L98/rust.git
git push -u origin main

//...或从命令行推送现有存储库
git remote add origin https://github.com/Derrick-L98/rust.git
git branch -M main
git push -u origin main


git push -u origin main -f  //意为强制推送。




```



# Redis是什么？

Redis（`Remote Dictionary Server`）是一个使用 C 语言编写的，高性能非关系型的键值对数据库。与传统数据库不同的是，Redis 的数据是存在内存中的，所以读写速度非常快，被广泛应用于缓存方向。Redis可以将数据写入磁盘中，保证了数据的安全不丢失，而且Redis的操作是原子性的。

## Redis优缺点？

**优点**：

1.  **基于内存操作**，内存读写速度快。
2.  Redis是**单线程**的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，即一个线程处理所有网络请求，Redis 运行时不止有一个线程，比如数据持久化的过程会另起线程。
3.  **支持多种数据类型**，包括String、Hash、List、Set、ZSet等。
4.  **支持持久化**。Redis支持RDB和AOF两种持久化机制，持久化功能可以有效地避免数据丢失问题。
5.  **支持事务**。Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
6.  **支持主从复制**。主节点会自动将数据同步到从节点，可以进行读写分离。

**缺点**：

1.  对结构化查询的支持比较差。
2.  数据库容量受到物理内存的限制，不适合用作[海量数据](https://www.nowcoder.com/jump/super-jump/word?word=海量数据)的高性能读写，因此Redis适合的场景主要局限在较小数据量的操作。
3.  Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

## Redis为什么这么快？

-   **基于内存**：Redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。
-   **单线程实现**（ Redis 6.0以前）：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。
-   **IO多路复用模型**：Redis 采用 IO 多路复用技术。Redis 使用单线程来轮询描述符，将数据库的操作都转换成了事件，不在网络I/O上浪费过多的时间。
-   **高效的数据结构**：Redis 每种数据类型底层都做了优化，目的就是为了追求更快的速度。

## Redis为何选择单线程

-   避免过多的**上下文切换开销**。程序始终运行在进程中单个线程内，没有多线程切换的场景。
-   **避免同步机制的开销**：如果 Redis选择多线程模型，需要考虑数据同步的问题，则必然会引入某些同步机制，会导致在操作数据过程中带来更多的开销，增加程序复杂度的同时还会降低性能。
-   **实现简单，方便维护**：如果 Redis使用多线程模式，那么所有的底层数据结构的设计都必须考虑线程安全问题，那么 Redis 的实现将会变得更加复杂。

## Redis6.0为何引入多线程？

Redis支持多线程主要有两个原因：

-   可以充分利用服务器 CPU 资源，单线程模型的主线程只能利用一个cpu；
-   多线程任务可以分摊 Redis 同步 IO 读写的负荷。

## Redis应用场景有哪些？

1.  **缓存热点数据**，缓解数据库的压力。
2.  利用 Redis 原子性的自增操作，可以实现**计数器**的功能，比如统计用户点赞数、用户访问数等。
3.  **简单的消息队列**，可以使用Redis自身的发布/订阅模式或者List来实现简单的消息队列，实现异步操作。
4.  **限速器**，可用于限制某个用户访问某个接口的频率，比如秒杀场景用于防止用户快速点击带来不必要的压力。
5.  **好友关系**，利用集合的一些命令，比如交集、并集、差集等，实现共同好友、共同爱好之类的功能。

## Memcached和Redis的区别？

1.  Redis 只使用**单核**，而 Memcached 可以使用多核。
2.  MemCached 数据结构单一，仅用来缓存数据，而 **Redis 支持多种数据类型**。
3.  MemCached 不支持数据持久化，重启后数据会消失。**Redis 支持数据持久化**。
4.  **Redis 提供主从同步机制和 cluster 集群部署能力**，能够提供高可用服务。Memcached 没有提供原生的集群模式，需要依靠客户端实现往集群中分片写入数据。
5.  Redis 的速度比 Memcached 快很多。
6.  Redis 使用**单线程的多路 IO 复用模型**，Memcached使用多线程的非阻塞 IO 模型。

## Redis 数据类型有哪些？

**基本数据类型**：

1、**String**：最常用的一种数据类型，String类型的值可以是字符串、数字或者二进制，但值最大不能超过512MB。

2、**Hash**：Hash 是一个键值对集合。

3、**Set**：无序去重的集合。Set 提供了交集、并集等方法，对于实现共同好友、共同关注等功能特别方便。

4、**List**：有序可重复的集合，底层是依赖双向[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)实现的。

5、**SortedSet**：有序Set。内部维护了一个`score`的参数来实现。适用于排行榜和带权重的消息队列等场景。

**特殊的数据类型**：

1、**Bitmap**：位图，可以认为是一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在 Bitmap 中叫做偏移量。Bitmap的长度与集合中元素个数无关，而是与基数的上限有关。

2、**Hyperloglog**。HyperLogLog 是用来做基数统计的[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，其优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。典型的使用场景是统计独立访客。

3、**Geospatial** ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如定位、附近的人等。

## keys命令存在的问题？

[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)的单线程的。keys指令会导致线程阻塞一段时间，直到执行完毕，服务才能恢复。scan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题，每次scan命令的时间复杂度是`O(1)`，但是要真正实现keys的功能，需要执行多次scan。

scan的缺点：在scan的过程中如果有键的变化（增加、删除、修改），遍历过程可能会有以下问题：新增的键可能没有遍历到，遍历出了重复的键等情况，也就是说scan并不能保证完整的遍历出来所有的键。

## SortedSet和List异同点？

**相同点**：

1.  都是有序的；
2.  都可以获得某个范围内的元素。

**不同点：**

1.  列表基于[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)实现，获取两端元素速度快，访问中间元素速度慢；
2.  有序集合基于散列表和跳跃表实现，访问中间元素时间复杂度是OlogN；
3.  列表不能简单的调整某个元素的位置，有序列表可以（更改元素的分数）；
4.  有序集合更耗内存。

## Redis事务

事务的原理是将一个事务范围内的若干命令发送给Redis，然后再让Redis依次执行这些命令。

事务的生命周期：

1.  使用MULTI开启一个事务
2.  在开启事务的时候，每次操作的命令将会被插入到一个队列中，同时这个命令并不会被真的执行
3.  EXEC命令进行提交事务

![img](https://uploadfiles.nowcoder.com/files/20211129/530285728_1638164818193/redis-multi.jpg)

一个事务范围内某个命令出错不会影响其他命令的执行，不保证原子性：

```c++
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set a 1 
QUEUED
127.0.0.1:6379> set b 1 2 
QUEUED
127.0.0.1:6379> set c 3 
QUEUED
127.0.0.1:6379> exec 
1 ) OK
2) (error) ERR syntax error
3) OK
```

**WATCH命令**

`WATCH`命令可以监控一个或多个键，一旦其中有一个键被修改，之后的事务就不会执行（类似于乐观锁）。执行`EXEC`命令之后，就会自动取消监控。

```c++
127.0.0.1:6379> watch name
OK
127.0.0.1:6379> set name 1
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set name 2
QUEUED
127.0.0.1:6379> set gender 1
QUEUED
127.0.0.1:6379> exec
(nil)
127.0.0.1:6379> get gender
(nil)
```

比如上面的代码中：

1.  `watch name`开启了对`name`这个`key`的监控
2.  修改`name`的值
3.  开启事务a
4.  在事务a中设置了`name`和`gender`的值
5.  使用`EXEC`命令进提交事务
6.  使用命令`get gender`发现不存在，即事务a没有执行

使用`UNWATCH`可以取消`WATCH`命令对`key`的监控，所有监控锁将会被取消。

## 持久化机制

持久化就是把**内存的数据写到磁盘中**，防止服务宕机导致内存数据丢失。

Redis支持两种方式的持久化，一种是`RDB`的方式，一种是`AOF`的方式。**前者会根据指定的规则定时将内存中的数据存储在硬盘上**，而**后者在每次执行完命令后将命令记录下来**。一般将两者结合使用。

### RDB方式

`RDB`是 Redis 默认的持久化方案。RDB持久化时会将内存中的数据写入到磁盘中，在指定目录下生成一个`dump.rdb`文件。Redis 重启会加载`dump.rdb`文件恢复数据。

`bgsave`是主流的触发 RDB 持久化的方式，执行过程如下：

![img](https://uploadfiles.nowcoder.com/files/20211129/530285728_1638164818455/rdb%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png)

-   执行`BGSAVE`命令
-   Redis 父进程判断当前**是否存在正在执行的子进程**，如果存在，`BGSAVE`命令直接返回。
-   父进程执行`fork`操作**创建子进程**，fork操作过程中父进程会阻塞。
-   父进程`fork`完成后，**父进程继续接收并处理客户端的请求**，而**子进程开始将内存中的数据写进硬盘的临时文件**；
-   当子进程写完所有数据后会**用该临时文件替换旧的 RDB 文件**。

Redis启动时会读取RDB快照文件，将数据从硬盘载入内存。通过 RDB 方式的持久化，一旦Redis异常退出，就会丢失最近一次持久化以后更改的数据。

触发 RDB 持久化的方式：

1.  **手动触发**：用户执行`SAVE`或`BGSAVE`命令。`SAVE`命令执行快照的过程会阻塞所有客户端的请求，应避免在生产环境使用此命令。`BGSAVE`命令可以在后台异步进行快照操作，快照的同时服务器还可以继续响应客户端的请求，因此需要手动执行快照时推荐使用`BGSAVE`命令。
2.  **被动触发**：
    -   根据配置规则进行自动快照，如`SAVE 100 10`，100秒内至少有10个键被修改则进行快照。
    -   如果从节点执行全量复制操作，主节点会自动执行`BGSAVE`生成 RDB 文件并发送给从节点。
    -   默认情况下执行`shutdown`命令时，如果没有开启 AOF 持久化功能则自动执行·BGSAVE·。

**优点**：

1.  **Redis 加载 RDB 恢复数据远远快于 AOF 的方式**。
2.  使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，**保证了 Redis 的高性能**。

**缺点**：

1.  **RDB方式数据无法做到实时持久化**。因为`BGSAVE`每次运行都要执行`fork`操作创建子进程，属于重量级操作，频繁执行成本比较高。
2.  RDB 文件使用特定二进制格式保存，Redis 版本升级过程中有多个格式的 RDB 版本，**存在老版本 Redis 无法兼容新版 RDB 格式的问题**。

### AOF方式

AOF（append only file）持久化：以独立日志的方式记录每次写命令，Redis重启时会重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是**解决了数据持久化的实时性**，AOF 是Redis持久化的主流方式。

默认情况下Redis没有开启AOF方式的持久化，可以通过`appendonly`参数启用：`appendonly yes`。开启AOF方式持久化后每执行一条写命令，Redis就会将该命令写进`aof_buf`缓冲区，AOF缓冲区根据对应的策略向硬盘做同步操作。

默认情况下系统**每30秒**会执行一次同步操作。为了防止缓冲区数据丢失，可以在Redis写入AOF文件后主动要求系统将缓冲区数据同步到硬盘上。可以通过`appendfsync`参数设置同步的时机。

```
appendfsync always ``//每次写入aof文件都会执行同步，最安全最慢，不建议配置``appendfsync everysec ``//既保证性能也保证安全，建议配置``appendfsync no ``//由操作系统决定何时进行同步操作
```

接下来看一下 AOF 持久化执行流程：

![img](https://uploadfiles.nowcoder.com/files/20211129/530285728_1638164818403/aof%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B0.png)

1.  所有的写入命令会追加到 AOP 缓冲区中。
2.  AOF 缓冲区根据对应的策略向硬盘同步。
3.  随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩文件体积的目的。AOF文件重写是把Redis进程内的数据转化为写命令同步到新AOF文件的过程。
4.  当 Redis 服务器重启时，可以加载 AOF 文件进行数据恢复。

**优点**：

1.  AOF可以更好的保护数据不丢失，可以配置 AOF 每秒执行一次`fsync`操作，如果Redis进程挂掉，最多丢失1秒的数据。
2.  AOF以`append-only`的模式写入，所以没有磁盘寻址的开销，写入性能非常高。

**缺点**：

1.  对于同一份文件AOF文件比RDB数据快照要大。
2.  数据恢复比较慢。

## RDB和AOF如何选择？

通常来说，应该同时使用两种持久化方案，以保证数据安全。

-   如果数据不敏感，且可以从其他地方重新生成，可以关闭持久化。
-   如果数据比较重要，且能够承受几分钟的数据丢失，比如缓存等，只需要使用RDB即可。
-   如果是用做内存数据，要使用Redis的持久化，建议是RDB和AOF都开启。
-   如果只用AOF，优先使用everysec的配置选择，因为它在可靠性和性能之间取了一个平衡。

当RDB与AOF两种方式都开启时，Redis会优先使用AOF恢复数据，因为AOF保存的文件比RDB文件更完整。

## Redis常见的部署方式有哪些？

Redis的几种常见使用方式包括：

-   单机版
-   Redis主从
-   Redis Sentinel（哨兵）
-   Redis Cluster

**使用场景**：

单机版：很少使用。存在的问题：1、内存容量有限 2、处理能力有限 3、无法高可用。

主从模式：master 节点挂掉后，需要手动指定新的 master，可用性不高，基本不用。

哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。

Redis cluster：主要是针对[海量数据](https://www.nowcoder.com/jump/super-jump/word?word=海量数据)+高并发+高可用的场景，如果是[海量数据](https://www.nowcoder.com/jump/super-jump/word?word=海量数据)，如果你的数据量很大，那么建议就用Redis cluster，所有主节点的容量总和就是Redis cluster可缓存的数据容量。

## 主从复制

Redis的复制功能是支持多个数据库之间的数据同步。主数据库可以进行读写操作，当主数据库的数据发生变化时会自动将数据同步到从数据库。从数据库一般是只读的，它会接收主数据库同步过来的数据。一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。

```
redis-server ``//启动Redis实例作为主数据库``redis-server --port ``6380` `--slaveof ``127.0``.``0.1` `6379` `//启动另一个实例作为从数据库``slaveof ``127.0``.``0.1` `6379``SLAVEOF NO ONE ``//停止接收其他数据库的同步并转化为主数据库。
```

**主从复制的原理？**

1.  当启动一个从节点时，它会发送一个 `PSYNC` 命令给主节点；
2.  如果是从节点初次连接到主节点，那么会触发一次全量复制。此时主节点会启动一个后台线程，开始生成一份 `RDB` 快照文件；
3.  同时还会将从客户端 client 新收到的所有写命令缓存在内存中。`RDB` 文件生成完毕后， 主节点会将`RDB`文件发送给从节点，从节点会先将`RDB`文件**写入本地磁盘，然后再从本地磁盘加载到内存中**；
4.  接着主节点会将内存中缓存的写命令发送到从节点，从节点同步这些数据；
5.  如果从节点跟主节点之间网络出现故障，连接断开了，会自动重连，连接之后主节点仅会将部分缺失的数据同步给从节点。

## 哨兵Sentinel

主从复制存在不能自动故障转移、达不到高可用的问题。哨兵模式解决了这些问题。通过哨兵机制可以自动切换主从节点。

客户端连接Redis的时候，先连接哨兵，哨兵会告诉客户端Redis主节点的地址，然后客户端连接上Redis并进行后续的操作。当主节点宕机的时候，哨兵监测到主节点宕机，会重新推选出某个表现良好的从节点成为新的主节点，然后通过发布订阅模式通知其他的从服务器，让它们切换主机。

![img](https://uploadfiles.nowcoder.com/files/20211129/530285728_1638164818367/sentinel.png)

**工作原理**

-   每个`Sentinel`以每秒钟一次的频率向它所知道的`Master`，`Slave`以及其他 `Sentinel`实例发送一个 `PING`命令。
-   如果一个实例距离最后一次有效回复 `PING` 命令的时间超过指定值， 则这个实例会被 `Sentine` 标记为主观下线。
-   如果一个`Master`被标记为主观下线，则正在监视这个`Master`的所有 `Sentinel`要以每秒一次的频率确认`Master`是否真正进入主观下线状态。
-   当有足够数量的 `Sentinel`（大于等于配置文件指定值）在指定的时间范围内确认`Master`的确进入了主观下线状态， 则`Master`会被标记为客观下线 。若没有足够数量的 `Sentinel`同意 `Master` 已经下线， `Master` 的客观下线状态就会被解除。 若 `Master`重新向 `Sentinel` 的 `PING` 命令返回有效回复， `Master` 的主观下线状态就会被移除。
-   哨兵节点会选举出哨兵 leader，负责故障转移的工作。
-   哨兵 leader 会推选出某个表现良好的从节点成为新的主节点，然后通知其他从节点更新主节点信息。

## Redis cluster

哨兵模式解决了主从复制不能自动故障转移、达不到高可用的问题，但还是存在主节点的写能力、容量受限于单机配置的问题。而cluster模式实现了Redis的分布式存储，每个节点存储不同的内容，解决主节点的写能力、容量受限于单机配置的问题。

Redis cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。

Redis cluster采用**虚拟槽分区**，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所映射的键值数据。

![img](https://uploadfiles.nowcoder.com/files/20211129/530285728_1638164818366/cluster_slots.png)

**哈希槽是如何映射到 Redis 实例上的？**

1.  对键值对的`key`使用 `crc16` [算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)计算一个结果
2.  将结果对 16384 取余，得到的值表示 `key` 对应的哈希槽
3.  根据该槽信息定位到对应的实例

**优点：**

-   无中心架构，**支持动态扩**容；
-   数据按照`slot`存储分布在多个节点，节点间数据共享，**可动态调整数据分布**；
-   **高可用性**。部分节点不可用时，集群仍可用。集群模式能够实现自动故障转移（failover），节点之间通过`gossip`协议交换状态信息，用投票机制完成`Slave`到`Master`的角色转换。

**缺点：**

-   **不支持批量操作**（pipeline）。
-   数据通过异步复制，**不保证数据的强一致性**。
-   **事务操作支持有限**，只支持多`key`在同一节点上的事务操作，当多个`key`分布于不同的节点上时无法使用事务功能。
-   `key`作为数据分区的最小粒度，不能将一个很大的键值对象如`hash`、`list`等映射到不同的节点。
-   **不支持多数据库空间**，单机下的Redis可以支持到16个数据库，集群模式下只能使用1个数据库空间。

### 哈希分区[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)有哪些？

节点取余分区。使用特定的数据，如Redis的键或用户ID，对节点数量N取余：hash（key）%N计算出哈希值，用来决定数据映射到哪一个节点上。
优点是简单性。扩容时通常采用翻倍扩容，避免数据映射全部被打乱导致全量迁移的情况。

一致性哈希分区。为系统中每个节点分配一个token，范围一般在0~232，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点。
这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。

虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式：slot=CRC16（key）&16383。每一个节点负责维护一部分槽以及槽所映射的键值数据。**Redis Cluser采用虚拟槽分区[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)。**

## 过期键的删除策略？

1、**被动删除**。在访问key时，如果发现key已经过期，那么会将key删除。

2、**主动删除**。定时清理key，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么就继续对这个db进行清理，否则开始清理下一个db。

3、**内存不够时清理**。Redis有最大内存的限制，通过maxmemory参数可以设置最大内存，当使用的内存超过了设置的最大内存，就要进行内存释放， 在进行内存释放的时候，会按照配置的淘汰策略清理内存。

## 内存淘汰策略有哪些？

当Redis的内存超过最大允许的内存之后，Redis 会触发内存淘汰策略，删除一些不常用的数据，以保证Redis服务器正常运行。

**Redisv4.0前提供 6 种数据淘汰策略**：

-   **volatile-lru**：LRU（`Least Recently Used`），最近使用。利用LRU[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)移除设置了过期时间的key
-   **allkeys-lru**：当内存不足以容纳新写入数据时，从数据集中移除最近最少使用的key
-   **volatile-ttl**：从已设置过期时间的数据集中挑选将要过期的数据淘汰
-   **volatile-random**：从已设置过期时间的数据集中任意选择数据淘汰
-   **allkeys-random**：从数据集中任意选择数据淘汰
-   **no-eviction**：禁止删除数据，当内存不足以容纳新写入数据时，新写入操作会报错

**Redisv4.0后增加以下两种**：

-   **volatile-lfu**：LFU，Least Frequently Used，最少使用，从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。
-   **allkeys-lfu**：当内存不足以容纳新写入数据时，从数据集中移除最不经常使用的key。

**内存淘汰策略可以通过配置文件来修改**，相应的配置项是`maxmemory-policy`，默认配置是`noeviction`。

## 如何保证缓存与数据库双写时的数据一致性？

**1、先删除缓存再更新数据库**

进行更新操作时，先删除缓存，然后更新数据库，后续的请求再次读取时，会从数据库读取后再将新数据更新到缓存。

存在的问题：删除缓存数据之后，更新数据库完成之前，这个时间段内如果有新的读请求过来，就会从数据库读取旧数据重新写到缓存中，再次造成不一致，并且后续读的都是旧数据。

**2、先更新数据库再删除缓存**

进行更新操作时，先更新MySQL，成功之后，删除缓存，后续读取请求时再将新数据回写缓存。

存在的问题：更新MySQL和删除缓存这段时间内，请求读取的还是缓存的旧数据，不过等数据库更新完成，就会恢复一致，影响相对比较小。

**3、异步更新缓存**

数据库的更新操作完成后不直接操作缓存，而是把这个操作命令封装成消息扔到消息队列中，然后由Redis自己去消费更新数据，消息队列可以保证数据操作顺序一致性，确保缓存系统的数据正常。

## 缓存穿透

缓存穿透是指查询一个**不存在的数据**，由于缓存是不命中时被动写的，如果从DB查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到DB去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了。

1.  **缓存空值**，不会查数据库。
2.  采用**布隆过滤器**，将所有可能存在的数据哈希到一个足够大的`bitmap`中，查询不存在的数据会被这个`bitmap`拦截掉，从而避免了对`DB`的查询压力。

布隆过滤器的原理：当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。查询时，将元素通过散列函数映射之后会得到k个点，如果这些点有任何一个0，则被检元素一定不在，直接返回；如果都是1，则查询元素很可能存在，就会去查询Redis和数据库。

## 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，**导致缓存在某一时刻同时失效**，请求全部转发到DB，DB瞬时压力过重挂掉。

解决方法：在原有的失效时间基础上**增加一个随机值**，使得过期时间分散一些。

## 缓存击穿

缓存击穿：大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都落到数据库。**缓存击穿是查询缓存中失效的 key，而缓存穿透是查询不存在的 key。**

解决方法：加分布式锁，第一个请求的线程可以拿到锁，拿到锁的线程查询到了数据之后设置缓存，其他的线程获取锁失败会等待50ms然后重新到缓存取数据，这样便可以避免大量的请求落到数据库。

```
public` `String get(String key) {``  ``String value = redis.get(key);``  ``if` `(value == ``null``) { ``//缓存值过期``    ``String unique_key = systemId + ``":"` `+ key;``    ``//设置30s的超时``    ``if` `(redis.set(unique_key, ``1``, ``'NX'``, ``'PX'``, ``30000``) == ``1``) { ``//设置成功``      ``value = db.get(key);``      ``redis.set(key, value, expire_secs);``      ``redis.del(unique_key);``    ``} ``else` `{ ``//其他线程已经到数据库取值并回写到缓存了，可以重试获取缓存值``      ``sleep(``50``);``      ``get(key); ``//重试``    ``}``  ``} ``else` `{``    ``return` `value;``  ``}``}
```

## Redis 怎么实现消息队列？

使用一个列表，让生产者将任务使用LPUSH命令放进列表，消费者不断用RPOP从列表取出任务。

>   BRPOP和RPOP命令相似，唯一的区别就是当列表没有元素时BRPOP命令会一直阻塞连接，直到有新元素加入。

```
BRPOP queue ``0` `//0表示不限制等待时间
```

**优先级队列**

如果多个键都有元素，则按照从左到右的顺序取元素。

```
BLPOP queue:``1` `queue:``2` `queue:``3` `0
```

**发布/订阅模式**

`PSUBSCRIBE channel?*` 按照规则订阅。
`PUNSUBSCRIBE channel?*` 退订通过PSUBSCRIBE命令按照某种规则订阅的频道。其中订阅规则要进行严格的字符串匹配，`PUNSUBSCRIBE *`无法退订`channel?*`规则。

```
PUBLISH channel1 hi``SUBSCRIBE channel1``UNSUBSCRIBE channel1 ``//退订通过SUBSCRIBE命令订阅的频道。
```

缺点：在消费者下线的情况下，生产的消息会丢失。

**延时队列**

使用sortedset，拿时间戳作为score，消息内容作为key，调用zadd来生产消息，消费者用`zrangebyscore`指令获取N秒之前的数据轮询进行处理。

## pipeline的作用？

[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)客户端执行一条命令分4个过程： 发送命令、命令排队、命令执行、返回结果。使用`pipeline`可以批量请求，批量返回结果，执行速度比逐条执行要快。

使用`pipeline`组装的命令个数不能太多，不然数据量过大，增加客户端的等待时间，还可能造成网络阻塞，可以将大量命令的拆分多个小的`pipeline`命令完成。

原生批命令（mset和mget）与`pipeline`对比：

1.  原生批命令是原子性，`pipeline`是**非原子性**。pipeline命令中途异常退出，之前执行成功的命令**不会回滚**。
2.  原生批命令只有一个命令，但`pipeline`**支持多命令**。

## LUA脚本

Redis 通过 LUA 脚本创建具有原子性的命令： 当lua脚本命令正在运行的时候，不会有其他脚本或 Redis 命令被执行，实现组合命令的原子操作。

在Redis中执行Lua脚本有两种方法：`eval`和`evalsha`。`eval`命令使用内置的 Lua 解释器，对 Lua 脚本进行求值。

```
//第一个参数是lua脚本，第二个参数是键名参数个数，剩下的是键名参数和附加参数``> eval ``"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}"` `2` `key1 key2 first second``1``) ``"key1"``2``) ``"key2"``3``) ``"first"``4``) ``"second"
```

**lua脚本作用**

1、Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令。

2、Lua脚本可以将多条命令一次性打包，有效地减少网络开销。

**应用场景**

举例：限制接口访问频率。

在Redis维护一个接口访问次数的键值对，`key`是接口名称，`value`是访问次数。每次访问接口时，会执行以下操作：

-   通过`aop`拦截接口的请求，对接口请求进行计数，每次进来一个请求，相应的接口访问次数`count`加1，存入[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)。
-   如果是第一次请求，则会设置`count=1`，并设置过期时间。因为这里`set()`和`expire()`组合操作不是原子操作，所以引入`lua`脚本，实现原子操作，避免并发访问问题。
-   如果给定时间范围内超过最大访问次数，则会抛出异常。

```
private` `String buildLuaScript() {``  ``return` `"local c"` `+``    ``"\nc = redis.call('get',KEYS[1])"` `+``    ``"\nif c and tonumber(c) > tonumber(ARGV[1]) then"` `+``    ``"\nreturn c;"` `+``    ``"\nend"` `+``    ``"\nc = redis.call('incr',KEYS[1])"` `+``    ``"\nif tonumber(c) == 1 then"` `+``    ``"\nredis.call('expire',KEYS[1],ARGV[2])"` `+``    ``"\nend"` `+``    ``"\nreturn c;"``;``}` `String luaScript = buildLuaScript();``RedisScript<Number> redisScript = ``new` `DefaultRedisScript<>(luaScript, Number.``class``);``Number count = redisTemplate.execute(redisScript, keys, limit.count(), limit.period());
```

PS：这种接口限流的实现方式比较简单，问题也比较多，一般不会使用，接口限流用的比较多的是令牌桶[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)和漏桶[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)。

## 什么是RedLock？

Redis 官方站提出了一种权威的基于 Redis 实现分布式锁的方式名叫 *Redlock*，此种方式比原先的单节点的方法更安全。它可以保证以下特性：

1.  安全特性：互斥访问，即永远只有一个 client 能拿到锁
2.  避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client 挂掉了
3.  容错性：只要大部分 Redis 节点存活就可以正常提供服务



# Redis

## redis是什么?

```c++
redis是一个使用C语言编写的,高新能非关系型的键值对数据库,与传统数据库不同的是,Redis的数据是存在内存中的,所以读写速度非常快,别广泛应用与缓存方向,Redis可以将数据写入磁盘中,保证数据的安全不会丢失,而且Redis的操作是原子性的.
```

## Redis优缺点

### 优点

```C++
1.基于内存操作,内存读写速度快.
2.Redis是单线程的,避免线程切换开销的竞争问题,单线程是指网络请求使用一个单线程来处理,即使用一个线程处理所有为网络请求,Redis运行时不止有一个线程,比如数据持久化的过程会另起一个线程.
3.支持多种数据类型,包括String,Hash,List,Set,ZSet等.
4.支持持久化,Redis支持RDB和AOF两种持久化机制，持久化功能可以有效地避免数据丢失问题。
5,支持事务,Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
6.支持主从复制。主节点会自动将数据同步到从节点，可以进行读写分离。
```

### 缺点

```C++
1.对结构化查询的支持比较差
2.

```

























```c++
从一个双链表中删除一个节点
从一个列表中删除一个节点的步骤如下（如图3.1） 
1. 找到要删除的节点N 

2. 更新前一个节点指向N的指针，让这个指针指向N的下一个节点 

3. 更新后一个节点指向N的指针，让这个指正指向N的前一个节点 

4. 删除节点N 
```

# GDB调试

```
什么是GDB，能干啥?
gdb是GNU开源组织发布的一个强大的Linux下的程序调试工具。

 一般来说，GDB主要帮助你完成下面四个方面的功能：
 1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。

2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）

3、当程序被停住时，可以检查此时你的程序中所发生的事。

4、你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。


gdb -c core 
记住几个常用的gdb命令：

l(list) ，显示源代码，并且可以看到对应的行号；

b(break)x, x是行号，表示在对应的行号位置设置断点；

p(print)x, x是变量名，表示打印变量x的值

r(run), 表示继续执行到断点的位置

n(next),表示执行下一步

c(continue),表示继续执行

q(quit)，表示退出gdb
```

## GDB基本调试命令

```C++
list 可写为l,可以列出所调试程序的代码
    1.list+linenumber
    可以列出linenumber附近的代码
    2.list function
    可以列出函数上下文的源程序
run  //在GDB中如何将程序运行起来，此时只要输入run命令,就可以将命令跑起来
quit //q 而quit则是退出GDB调试
    
gdb调试时使用break命令来设置断点，有如下几种下断点地方法
break < function >  //在进入指定的函数function时既停止运行，C++中可以使用class::function或function(type, type)格式来指定函数名称
break < lineNumber> //在指定的代码行打断点
break +offset/break -offset //在当前行的前面或后面的offset行打断点，offset为自然数
break filename:lineNumber 	//在名称为filename的文件中的第lineNumber行打断点
break filename:function 	//在名称为filename的文件中的function函数入口处打断点
break *address //在程序运行的内存地址处打断点
break //在下一条命令处停止运行
break … if < condition> //在处理某些循环体中可使用此方法进行调试，其中…可以是上述的...可以是上述的break lineNumber、
//break +offset/break -offset中的参数，其中condition表示条件，在条件成立时程序即停止运行，如设置break if i=100表示当i为100时程序停止运行。
//查看断点时，也可以使用info命令如info breakpoints [n]、info break [n]其中n 表示断点号来查看断点信息。
  
可以通过delete命令删除所有的断点
next  
    //使用next命令单步执行程序代码，
```



## GDB常用的调试命令

```C++
（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h

（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r

（gdb）start：单步执行，运行程序，停在第一执行语句

（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l

（gdb）set：设置变量的值

（gdb）next：单步调试（逐过程，函数直接执行）,简写n

（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s

（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt

（gdb）frame：切换函数的栈帧,简写f

（gdb）info：查看函数内部局部变量的数值,简写i

（gdb）finish：结束当前函数，返回到函数调用点

（gdb）continue：继续运行,简写c

（gdb）print：打印值及地址,简写p

（gdb）quit：退出gdb,简写q

（gdb）break+num：在第num行设置断点,简写b

（gdb）info breakpoints：查看当前设置的所有断点

（gdb）delete breakpoints num：删除第num个断点,简写d

（gdb）display：追踪查看具体变量值

（gdb）undisplay：取消追踪观察变量

（gdb）watch：被设置观察点的变量发生修改时，打印显示

（gdb）i watch：显示观察点

（gdb）enable breakpoints：启用断点

（gdb）disable breakpoints：禁用断点

（gdb）x：查看内存x/20xw 显示20个单元，16进制，4字节每单元

（gdb）run argv[1] argv[2]：调试时命令行传参
```

## GDB 调试core文件

```C++
Linux core dump:一般称为核心转储,内核转储
    ps aux | grep SvrStockEnable
    gdb attach 18579
   
    gdb <程序> <core>
    where
```

# 电脑快捷键

```
//截图
安装了qq或者微信:ctrl+Alt+a 或者 Alt + a
自定义:win + shift + s
全屏截图:win + W

切换应用:Win+Tab
		Alt+Tab
Crtl+Tab 组合键是用来切换同一程序内不同的窗口
```

# 区块链

```
区块链是什么:区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。是比特币的一个重要概念，它本质上是一个去中心化的数据库，同时作为比特币的底层技术，是一串使用密码学方法相关联产生的数据块。
```

# golong

```go
https://books.studygolang.com/gopl-zh/ch4/ch4-02.html
https://chai2010.cn/advanced-go-programming-book/ch5-web/ch5-07-layout-of-web-project.html


%b	表示为二进制
%c	该值对应的unicode码值
%d	表示为十进制
%o	表示为八进制
%q	该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示
%x	表示为十六进制，使用a-f
%X	表示为十六进制，使用A-F
%U	表示为Unicode格式：U+1234，等价于"U+%04X"

%b	无小数部分、二进制指数的科学计数法，如-123456p-78；参见strconv.FormatFloat
%e	科学计数法，如-1234.456e+78
%E	科学计数法，如-1234.456E+78
%f	有小数部分但无指数部分，如123.456
%F	等价于%f
%g	根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）
%G	根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）

%s	直接输出字符串或者[]byte
%q	该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示
%x	每个字节用两字符十六进制数表示（使用a-f）
%X	每个字节用两字符十六进制数表示（使用A-F）    

func Printf(format string, a ...interface{}) (n int, err error)
//Printf根据format参数生成格式化的字符串并写入标准输出。返回写入的字节数和遇到的任何错误。
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
//Fprintf根据format参数生成格式化的字符串并写入w。返回写入的字节数和遇到的任何错误。
func Sprintf(format string, a ...interface{}) string
//Sprintf根据format参数生成格式化的字符串并返回该字符串。
func Print(a ...interface{}) (n int, err error)
//Print采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。返回写入的字节数和遇到的任何错误。
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
//Fprint采用默认格式将其参数格式化并写入w。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。返回写入的字节数和遇到的任何错误。
func Sprint(a ...interface{}) string
//Sprint采用默认格式将其参数格式化，串联所有输出生成并返回一个字符串。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。
func Println(a ...interface{}) (n int, err error)
//Println采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。返回写入的字节数和遇到的任何错误。
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
//Fprintln采用默认格式将其参数格式化并写入w。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。返回写入的字节数和遇到的任何错误。
func Sprintln(a ...interface{}) string
//Sprintln采用默认格式将其参数格式化，串联所有输出生成并返回一个字符串。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。
func Errorf(format string, a ...interface{}) error
//Errorf根据format参数生成格式化字符串并返回一个包含该字符串的错误。
func Scanf(format string, a ...interface{}) (n int, err error)
//Scanf从标准输入扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
//Fscanf从r扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
//Sscanf从字符串str扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。
func Scan(a ...interface{}) (n int, err error)
//Scan从标准输入扫描文本，将成功读取的空白分隔的值保存进成功传递给本函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。
```

```go
取模：%
10 % 3 =》 1
-10 % 3 =》-1
10 % -3 =》1
-10 % -3 =》-1
公式：a%b = a - a / b * b
```



## 字符串常用函数

```go
统计字符串长度： len(str)
字符串遍历，同时处理中文的问题   r := []rune(str)
字符串转整数：  n,err := strconv.Atoi("112")
整数转字符串： str := strconv.Itoa(1123)
查找子串是否在指定的字符串中： strings.Contains("dfasfds","fdsafd")
统计一个字符串中有几个子串： strings.Count("ceheese","e")

不区分大小写的字符串比较： strings.EqualFold("asd","aSd")
返回子串在字符串第一次出现的位置，如果没有返回-1： strings.Index("ASFG_asd","asd")
按照指定的某个字符，为分割符，将一个字符串拆分成字符串数组： strings.Split("hello|world|go","|")
将字符出的字母进行大小写转换： strings.ToLower("Go")//全部改为小写
strings.ToUpper("go")//全部改为大写
将字符串左右两边的空格去掉： strings.TrimSpace(" fdafd fdas      ")
将字符串左右两边指定的字符去掉：strings.Trim("!  fasdf !","!")//TrimLeft 左边 TrimRight右边
```

## 日期相关函数

```go
//引入time包
获取当前时间：time.Now()//返回类型是：time.Time：Time为结构体
now := time.Now()
年： now.Year()
月： now.Month()//返回英文月
月： int(now.Month())//阿拉伯数字
日： now.Day()
时： now.Hour()
分： now.Minute()
秒： now.Second()

格式化日期和时间
fmt.Sprintf()
%02d-%02d-%02d %02d:%02d:%02d

now.Format("2006/01/02 15:04:05")//数字不能变，格式可以调

时间戳：
now.Unix()//now.UnixNano()

检测性能的方法：可以测一个函数的执行时间长短
func main() {
    start := time.Now().Unix()//time.Now().UnixNano()
    test()
    end := time.Now().Unix()//time.Now().UnixNano()
    fmt.Printf("耗时 %v 秒\n",end-start)
}
```

## grpc

```go
使用以下命令安装 Go 的协议编译器插件：
go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2

export PATH="$PATH:$(go env GOPATH)/bin"    //PATH="$PATH:$(go env GOPATH)/bin" 


在使用新的服务方法之前，需要重新编译更新后的文件。.proto
当仍在目录中时，运行以下命令：examples/helloworld

protoc --go_out=. --go_opt=paths=source_relative \
    --go-grpc_out=. --go-grpc_opt=paths=source_relative \
    helloworld/helloworld.proto



生成客户端和服务器代码
接下来，我们需要从服务定义生成 gRPC 客户端和服务器接口。我们使用带有特殊gRPC Go插件的协议缓冲区编译器来执行此操作。这类似于我们在快速入门中所做的。.protoprotoc
从目录中，运行以下命令：examples/route_guide
$ protoc --go_out=. --go_opt=paths=source_relative \
    --go-grpc_out=. --go-grpc_opt=paths=source_relative \
    routeguide/route_guide.proto


在生成 客户端服务端代码时需要在proto文件中导入

option go_package = "google.golang.org/grpc/examples/test/marketdata";
```





# 正则表达式

```c++

```



## 股票基础

```rust
分时线即大盘、个股分时走势图中的白色曲线，它反映的是大盘、个股的实时走势。
//1)白色曲线：表示该种股票即时实时成交的价格。
//2)黄色曲线：表示该种股票即时成交的平均价格，即当天成交总金额除以成交总股数。
3)黄色柱线：在红白曲线图下方，用来表示每一分钟的成交量。
4)成交明细：在盘面的右下方为成交明细显示，显示动态每笔成交的价格和手数。
5)外盘内盘：外盘又称主动性买盘，即成交价在卖出挂单价的累积成交量；内盘主动性卖盘，即成交价在买入挂单价的累积成交量。外盘反映买方的意愿，内盘反映卖方的意愿。
6)量比：是指当天成交总手数与近期成交手数平均的比值，具体公式为：现在总手/((5日平均总手/240)*开盘多少分钟)。量比数值的大小表示近期此时成交量的增减，大于1表示此时刻成交总手数已经放大，小于1表示表示此时刻成交总手数萎缩。
实战中的K线分析，必须与即时分时图分析相结合，才能真实可靠的读懂市场的语言，洞悉盘面股价变化的奥妙。K线形态分析中的形态颈线图形，以及波浪角度动量等分析的方法原则，也同样适合即时动态分时走势图分析
日k线图又称阴阳烛，最初是日本米商用来表示米价涨跌状况的工具，后来引入股市，并逐渐风行于东南亚地区。K线图以其直观、立体感强的特点而深受投资者欢迎。实践证明，精研K线图可以较准确地预测后市走向，也可以较明确地判断多空双方的力量对比，从而为投资决策提供重要参考。
日K线是根据股价(指数）一天的走势中形成的四个价位即：开盘价，收盘价，最高价，最低价绘制而成的。收盘价高于开盘价时，则开盘价在下收盘价在上，二者之间的长方柱用红色或空心绘出，称之为阳线；（收集整理）其上影线的最高点为最高价，下影线的最低点为最低价。
收盘价低于开盘价时，则开盘价在上收盘价在下，二者之间的长方柱用黑色或实心绘出，称之为阴线，其上影线的最高点为最高价，下影线的最低点为最低价。
日K线图就是将每天的K线按时间顺序排列在一起，反映该股票自上市以来的每天的价格变动情况的K线图。
```

