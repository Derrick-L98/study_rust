2021.10.19work record：
    成交服处理新增字段
        //持仓表
        en_total_value_hkd` decimal(20,4) NOT NULL DEFAULT '0.0000' COMMENT '港币结算开仓市值',
        en_begin_value_hkd` decimal(20,4) NOT NULL DEFAULT '0.0000' COMMENT '港币结算每日初始开仓市值',

    处理：
        1.成交表港币成本计算
        买：
        港币成本 = en_total_value_hkd + deal_amount * deal_price * hkd_rate
        卖：
        avg_price_hkd = en_total_value_hkd/current_amount                                   ：en_total_value_hkd从数据库查出来
        en_total_value_hkd:成交前港币总成本：？
        current_amount:成交前总数量

        港币成本 = en_total_value_hkd - deal_amount * avg_price_hkd

        2.交收表盈亏计算
        profit_hkd = en_refer_profit = (deal_price * hkd_rate - avg_price_hkd)*deal_amount

        3.资产表盈亏计算
        en_total_profit = en_total_profit + profit_hkd


rust:
    通过引用可以在代码的不同的位置访问同一块内存

    let mut guess = String::new();
    let guess: u32  = guess.trim().parse().expect("出错了");如：字符串100  ，成功。fadsfd，失败（无法解析）
                ^
                |
        指定类型，否则有歧义，无法解析
        trim();//会将字符串的空格部分去掉，包括回车\n
        parse();//将字符串类型解析成某种类型，需要提供u32, 返回Result（枚举）类型：成功：OK(), 失败： err()

    随机数生成：
        let secret_number = rand::thread_rng().gen_range(1,101);

    引用：允许你使用某些值而不取得所有权
    借用：把引用作为函数参数这个行为叫做借用
            和变量一样，引用默认也是不可变的，不可以修改借用的东西（可变引用）

    
    错误处理：
        Result（枚举）
        enum Result<T, E> {
            Ok(T),
            Err(E),
        }
        T:  操作成功情况下,Ok变体里返回的数据的类型
        E:  操作失败情况下,Err变体里返回的错误的类型

        处理Result的一种方式：match表达式
            Option, Result都是由prelude带入作用域

        use std::fs::file;
        use std::io::ErrorKind;

        fn main() {
            let f = File::Open("hello.txt");//打开一个文件
            let f = match f {
                Ok(file) => file,//成功返回文件
                Err(error) => match error.kind() {//没有这个文件
                    ErrorKind::NotFound => match File::create("hello.txt") {//失败则创建 
                        Ok(fc) => fc,
                        Err(e) => panic!("Error creating file: {:?}", e),
                    },
                    oe => panic!("Error opening the file: {:?}", oe),//其他错误
                },
                
            };
        }
        //可使用闭包优化代码，使得代码更简洁，

        Result的unwrap方法：match表达式的一个快捷方法。
            如果Result结果是OK，返回OK里边的值
            如果Result结果是Err，调用panic!宏
    
        expect：和unwrap类似，但可以指定错误信息


    en_total_value_hkd = en_total_value_hkd + 21.806061


    pDealData->dReferProfit = (pDealData->dDealPrice - dAvgPrice) * pDealData->iDealAmount;//成交表的
    dTotalValueHKD = pDealData->iDealAmount * pDealData->dDealPrice * dRate;//买
    dTotalValueHKD = dTotalValueHKD - pDealData->iDealAmount * dAvgPriceHKD;;//卖
        dProfitHKD = (pDealData->dDealPrice * dRate - dAvgPriceHKD) * pDealData->iDealAmount;
        profit_hkd = en_refer_profit = (deal_price * hkd_rate - avg_price_hkd)*deal_amount;//交收
    en_total_profit = en_total_profit + profit_hkd;//资产


    【数据库】同一字段根据不同条件更新的sql语句的写法
语法：

update test    

set 字段1=case when 条件1 then 值1    

       when 条件2 then 值2              

     end  

 

示例：

update PMS_ProjectInfo set ProProgress=case when ProProgress+@ProProgress >=1 then 1 else ProProgress+@ProProgress end where ProjectID=@ProjectID  

c函数库
#include <time.h>

C 库函数 struct tm *localtime(const time_t *timer) 使用 timer 的值来填充 tm 结构。timer 的值被分解为 tm 结构，并用本地时区表示。

声明
下面是 localtime() 函数的声明。

struct tm *localtime(const time_t *timer)
参数
timer -- 这是指向表示日历时间的 time_t 值的指针。
返回值
该函数返回指向 tm 结构的指针，该结构带有被填充的时间信息。下面是 tm 结构的细节：

struct tm {
   int tm_sec;         /* 秒，范围从 0 到 59                */
   int tm_min;         /* 分，范围从 0 到 59                */
   int tm_hour;        /* 小时，范围从 0 到 23                */
   int tm_mday;        /* 一月中的第几天，范围从 1 到 31                    */
   int tm_mon;         /* 月份，范围从 0 到 11                */
   int tm_year;        /* 自 1900 起的年数                */
   int tm_wday;        /* 一周中的第几天，范围从 0 到 6                */
   int tm_yday;        /* 一年中的第几天，范围从 0 到 365                    */
   int tm_isdst;       /* 夏令时                        */    
};
实例
下面的实例演示了 localtime() 函数的用法。

实例
#include <stdio.h>
#include <time.h>
 
int main ()
{
   time_t rawtime;
   struct tm *info;
   char buffer[80];
 
   time( &rawtime );
 
   info = localtime( &rawtime );
   printf("当前的本地时间和日期：%s", asctime(info));
 
   return(0);
}
编译并运行上面的程序，这将产生以下结果：
当前的本地时间和日期：Thu Aug 23 09:12:05 2012


size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)
参数
str -- 这是指向目标数组的指针，用来复制产生的 C 字符串。
maxsize -- 这是被复制到 str 的最大字符数。
format -- 这是 C 字符串，包含了普通字符和特殊格式说明符的任何组合。这些格式说明符由函数替换为表示 tm 中所指定时间的相对应值。格式说明符是：

说明符	替换为	实例
%a	缩写的星期几名称	Sun
%A	完整的星期几名称	Sunday
%b	缩写的月份名称	Mar
%B	完整的月份名称	March
%c	日期和时间表示法	Sun Aug 19 02:56:02 2012
%d	一月中的第几天（01-31）	19
%H	24 小时格式的小时（00-23）	14
%I	12 小时格式的小时（01-12）	05
%j	一年中的第几天（001-366）	231
%m	十进制数表示的月份（01-12）	08
%M	分（00-59）	55
%p	AM 或 PM 名称	PM
%S	秒（00-61）	02
%U	一年中的第几周，以第一个星期日作为第一周的第一天（00-53）	33
%w	十进制数表示的星期几，星期日表示为 0（0-6）	4
%W	一年中的第几周，以第一个星期一作为第一周的第一天（00-53）	34
%x	日期表示法	08/19/12
%X	时间表示法	02:50:06
%y	年份，最后两个数字（00-99）	01
%Y	年份	2012
%Z	时区的名称或缩写	CDT
%%	一个 % 符号	%
timeptr -- 这是指向 tm 结构的指针，该结构包含了一个呗分解为以下各部分的日历时间：
struct tm {
   int tm_sec;         /* 秒，范围从 0 到 59                */
   int tm_min;         /* 分，范围从 0 到 59                */
   int tm_hour;        /* 小时，范围从 0 到 23                */
   int tm_mday;        /* 一月中的第几天，范围从 1 到 31                    */
   int tm_mon;         /* 月份，范围从 0 到 11                */
   int tm_year;        /* 自 1900 起的年数                */
   int tm_wday;        /* 一周中的第几天，范围从 0 到 6                */
   int tm_yday;        /* 一年中的第几天，范围从 0 到 365                    */
   int tm_isdst;       /* 夏令时                        */    
};

#include <iostream>
#include <stdio.h>
#include <time.h>

std::string GetSysTime(std::string fmt)
{
    time_t tmptime;
    struct tm *nowtime;
    char timestr[30] = ""; 
    time(&tmptime);
    nowtime = localtime(&tmptime);
    //"%Y-%m-%d %H:%M:%S.000"
    if (fmt.empty()) fmt = "%Y-%m-%d";
    //if (fmt.empty()) fmt = "%Y-%m-%d %H:%M:%S";
    strftime(timestr, sizeof(timestr), fmt.c_str(), nowtime);
    return std::string(timestr);
}

 int main ()
 {
     std::string time;
     time = GetSysTime("%Y%m%d");
     std::cout << time << std::endl;
     printf("%s",time.c_str());
 }


 Rusult<T, E>，成功返回T类型，失败返回错误信息

 pub fn run(config: Config) -> Result<(), Box<dyn Error>> //不返回什么的时候这样写；错误处理


周报模板：
 第一类是互联网和IT类企业，周报月报的形式多为固定模板，本周做了哪些模块，有什么有亮点的事情，过程是如何，遇到困难是如何解决的。

-   3-1 周报标题；
-   3-2 完成事项；
-   3-3 未完成事项；
-   3-4 解决问题的方案；
-   3-5 待办事项；

### 应该写些什么

简要概括如下

-   汇报一些工作上的内容

-   工作内容以外的收获，自己的经验值和学习心得

-   工作上的另一种沟通方式，向领导提一些有关工作的建设性的意见


UpdateStockPositionForSale函数
//在更新表字段数据时做小于0判断，小于置0，否则，按原来的数据更新
" l_temp_frozen_amount = case when (coalesce(l_temp_frozen_amount, 0) + %d) < 0 then 0 "
"    else coalesce(l_temp_frozen_amount, 0) + %d end, "
" l_prebuy_amount = case when (coalesce(l_prebuy_amount, 0) + %d) < 0 then 0 "
"    else coalesce(l_prebuy_amount, 0) + %d end, "
" l_presale_amount = case when (coalesce(l_presale_amount, 0) + %d) < 0 then 0 "
"    else coalesce(l_presale_amount, 0) + %d end, "




rust查找子串方法
pub fn contains<'a, P>(&'a self, pat: P) -> bool
where
    P: Pattern<'a>, 

Returns if the given pattern matches a sub-slice of this string slice.true
Returns if it does not.false
The pattern can be a , char, a slice of chars, or a function or closure that determines if a character matches.&str
Examples
Basic usage:


let bananas = "bananas";

assert!(bananas.contains("nana"));
assert!(!bananas.contains("apples"));